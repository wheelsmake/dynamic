{"version":3,"file":"dynamic.min.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///../utils/generic.ts","webpack:///../utils/element.ts","webpack:///./src/utils/data.ts","webpack:///./src/utils/misc.ts","webpack:///./src/libs/cycle.ts","webpack:///./src/app.ts","webpack:///../utils/arguments.ts","webpack:///./src/template.ts","webpack:///./src/spa.ts","webpack:///./src/manifest.ts","webpack:///./src/dynamic.export.ts","webpack:///./src/dynamic.defineGlobal.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function randoma2Z(length :number) :string{ //52\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 52);\r\n        if(r > 25) s += String.fromCharCode(r + 71);\r\n        else s += String.fromCharCode(r + 65);\r\n    }\r\n    return s;\r\n}\r\nexport function randoma2z029(length :number) :string{ //36\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 36);\r\n        if(r < 10) s += r;\r\n        else s += String.fromCharCode(r + 87);\r\n    }\r\n    return s;\r\n}\r\nexport function precisePop<T>(ele :T, array :any[]) :T | null{\r\n    if(array.indexOf(ele) === -1) return null;\r\n    return array.splice(array.indexOf(ele), 1)[0];\r\n}\r\n//递归冻结对象\r\nexport function constantize(obj :anyObject) :void{\r\n    Object.freeze(obj);\r\n    for(let i = 0; i < Object.keys(obj).length; i++) if(typeof obj[Object.keys(obj)[i]] == \"object\") constantize(obj[Object.keys(obj)[i]]);\r\n}\r\nexport function E(argument :string, type? :string, value? :any, reason? :string) :never{\r\n    if(argument === undefined) throw new Error(\"An error occured.\");\r\n    else{\r\n        console.error(\"ERROR INFO: argument\", argument, \",type\", type, \",value\", value, \",reason\", reason); //为了拿到真正的value，其他类型toString后啥信息都没了\r\n        throw new Error(`Argument '${argument}' ${type ? `should be a(an) ${type}` : \"is invalid\"}${reason ? `, reason: ${reason}` : \"\"}${value ? `, got ${value}` : \"\"}.`);\r\n    }\r\n}\r\nexport function EE(message :any) :never{throw new Error(message);}\r\nexport function repeat<T>(item :T, count :number) :T[]{\r\n    if(typeof count != \"number\" || count < 1) utils.generic.E(\"count\", \"integer bigger than 0\", count);\r\n    return Array(count).fill(item, 0, count);\r\n}\r\nexport function noRepeat<T>(input :T[]) :T[]{\r\n    return Array.from(new Set(input)); //Set可是连IE11都支持的东西啊\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function e(s :string, scope? :Element | Document) :Node[] | Node{\r\n    if(scope === undefined || !(scope instanceof Element)) scope = document;\r\n        let a :NodeList = scope.querySelectorAll(s);\r\n        if(!a.length) return [];\r\n        //note:当一个页面存在相同ID元素时不会走这里，而会返回数组，因为说好了是querySelectorAll了并且本来就不应该有重复ID，不能怪我啊\r\n        if(a.length == 1 && s.match(/^.*#[^\\s]*$/)) return a[0];\r\n        else return Array.from(a);\r\n}\r\n/**@deprecated use `Node.contains` instead.*/\r\nexport function isDescendant(possibleDescendant :Node, possibleParent :Node) :boolean{\r\n    return possibleParent.contains(possibleDescendant);\r\n    /*while(\r\n        possibleDescendant instanceof Text\r\n     || (possibleDescendant instanceof Element && possibleDescendant.tagName != \"HTML\")\r\n    ){\r\n        possibleDescendant = possibleDescendant.parentNode! as Element;\r\n        if(possibleDescendant === possibleParent) return true; \r\n    }\r\n    return false;*/\r\n}\r\nexport function isInDocument(node :Node) :boolean{\r\n    return ((e(\"html\") as Node[])[0]).contains(node);\r\n    //return isDescendant(element, (e(\"html\") as Node[])[0] as Element);\r\n}\r\nexport function isChild(node :Node, target :Element) :boolean{\r\n    return Array.from(target.childNodes).indexOf(node as ChildNode) != -1;\r\n    /*const children = target.childNodes;\r\n    for(let i = 0; i < children.length; i++) if(element === children[i]) return true;\r\n    return false;*/\r\n}\r\nexport function toHTML(HTML :string) :Node[]{\r\n    if(HTML === \"\" || typeof HTML != \"string\") utils.generic.E(\"HTML\", \"string\", HTML);\r\n    const ele = document.createElement(\"div\");\r\n    ele.innerHTML = HTML;\r\n    return getInnerNodesClone(ele);\r\n}\r\nexport function getInnerNodesClone(el :Node) :Node[]{\r\n    var nodes :Node[] = [];\r\n    for(let i = 0; i < el.childNodes.length; i++) nodes[i] = el.childNodes[i].cloneNode(true);\r\n    return nodes;\r\n}\r\n//剥壳器\r\nexport function hatch(element :Element, remove? :boolean) :Node[]{\r\n    //note:Nodelist类型会实时同步造成不稳定的for循环，必须转换为Node[]！\r\n    const par = element.parentElement!, children :Node[] = Array.from(element.childNodes);\r\n    for(let i = 0; i < children.length; i++) par.insertBefore(children[i], element);\r\n    if(remove === true) element.remove();\r\n    return children;\r\n}\r\n//fixme:这个方法特异性太强了吧，能不能不要放在这里？\r\n//最终渲染方法，老祖宗求你别出bug\r\nexport function render(\r\n    HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[],\r\n    element :Element,\r\n    insertAfter? :boolean,\r\n    append? :boolean\r\n) :Node[]{\r\n    if(element.parentElement === null) utils.generic.EE(\"cannot render by '<html>' element, since it's root of document.\");\r\n    var html :Node[] = [];\r\n    if(typeof HTML == \"string\") html = toHTML(HTML);\r\n    else if(HTML instanceof Element || HTML instanceof Node) html[0] = HTML.cloneNode(true);\r\n    else if(HTML instanceof HTMLCollection || HTML instanceof NodeList) for(let i = 0; i < HTML.length; i++) html[i] = HTML.item(i)!.cloneNode(true);\r\n    else html = HTML;\r\n    const Rhtml = [...html].reverse(), parent = element.parentElement;\r\n    if(append === true) for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    else if(append === false) for(let i = 0; i < Rhtml.length; i++) element.prepend(Rhtml[i]);\r\n    else if(insertAfter === true){\r\n        if(!element.nextSibling) for(let i = 0; i < Rhtml.length; i++) parent!.append(Rhtml[i]);\r\n        else for(let i = 0; i < Rhtml.length; i++) parent!.insertBefore(Rhtml[i], element.nextSibling);\r\n    }\r\n    else if(insertAfter === false) for(let i = 0; i < html.length; i++) parent!.insertBefore(html[i], element);\r\n    else for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    //todo:加入作用域\r\n    return html;\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nexport function createData<T>(\r\n    value? :T,\r\n    shouldUpdate? :shouldUpdateA,\r\n    shouldExport? :shouldExportA\r\n) :data<T>{\r\n    const result :data<T> = {\r\n        value,\r\n        deleted: false,\r\n        shouldUpdates: shouldUpdate || [],\r\n        shouldExports: shouldExport || []\r\n    }\r\n    if(isComputedProperty(result)) result.cache = undefined;\r\n    return result;\r\n}\r\n/**这里如果添加成功会自动引发一次针对性的export*/\r\nexport function addExport<T>(proxy :anyObject, dataInstance :data<T>, func :exportFunc, target? :Node) :shouldExportA{\r\n    const sE = dataInstance.shouldExports, funcString = func.toString();\r\n    //检测函数是否是箭头函数，箭头函数拿不到this，一定会出错\r\n    if(funcString.match(/^\\([^\\(\\)]*\\)[\\s]*=>/)) utils.generic.E(\"func\", \"exportFunc\", func, \"export function must not be an arrow function\");\r\n    //检测shouldExport里是不是已经有了完全相同的函数。很不幸，由于添加了target，我们需要手动遍历数组了\r\n    //important:这里的函数还是原函数，不能bind，不然后面查重就失效了，我们等到用的时候再bind也不迟，并且分析函数还需要bind不同的东西\r\n    let isDuplicated = false;\r\n    for(let i = 0; i < sE.length; i++) if(sE[i][0] === func){\r\n        isDuplicated = true;\r\n        break;\r\n    }\r\n    if(isDuplicated) console.warn(\"Duplicated function\", func, \"is blocked being added to data\", dataInstance);\r\n    else{\r\n        const instance :exportInstance = [func, target];\r\n        sE.push(instance);\r\n        //在这里会立即引发一次针对性的export，oldValue与现在的value相同\r\n        (func.bind(proxy))(instance, dataInstance.value);\r\n    }\r\n    return sE;\r\n}\r\nexport function removeExport<T>(dataInstance :data<T>, func :string | exportFunc) :shouldExportA{\r\n    const sE = dataInstance.shouldExports;\r\n    if(typeof func == \"string\"){\r\n        if(func == \"__addedByDynamic__\") utils.generic.E(\"func\", \"string | exportFunc\", func, \"this name is reserved\");\r\n        else if(func == \"\") console.warn(\"Operation blocked trying to remove ALL annoymous functions. Use the function itself for argument instead.\");\r\n        //注意这里会删除所有同名函数！\r\n        else for(let i = 0; i < sE.length; i++) if(sE[i][0].name === func) utils.generic.precisePop(sE[i], sE);\r\n    }\r\n    //由于添加了target，这里需要遍历数组\r\n    else if(typeof func == \"function\") for(let i = 0; i < sE.length; i++) if(sE[i][0] === func) utils.generic.precisePop(sE[i], sE); //不是exportFunc没关系；precisePop已经处理了-1\r\n    else utils.generic.E(\"func\", \"string | exportFunc\", func);\r\n    return sE;\r\n}\r\n/**return typeof data.value == \"function\";*/\r\nexport function isComputedProperty<T>(data :data<T>) :boolean{\r\n    return typeof data.value == \"function\";\r\n}\r\nexport function pushCache(){\r\n\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nimport * as cycle from \"../libs/cycle\";\r\nexport function eliminateSymbol(property :string | Symbol) :string{\r\n    if(typeof property == \"symbol\") utils.generic.E(property.toString(), \"string\", property,  \"index of Dynamic.data must not be a Symbol\");\r\n    return property as string;\r\n}\r\nconst toString = Object.prototype.toString;\r\n/**Not `JSON.stringify`, more than `JSON.stringify`.*/\r\nexport function advancedStringify(input :object) :string{\r\n    if(typeof input != \"object\") utils.generic.E(\"input\", \"object\", input);\r\n    //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#%E5%BC%82%E5%B8%B8\r\n    //用这个记录事后将不应该加双引号的类型去除双引号，避免如\"undefined\"（typeof string）和undefined（typeof undefined）都变成\"undefined\"的情况\r\n    //const patchList :[string[], string[], object[]] = [[], [], []];\r\n    if(input === null) return \"null\"; //不要{}了\r\n    else{\r\n        let result :string = \"{\";\r\n        //我们只对元素本身的、可枚举的属性进行提取，即Object.keys得到的东西。\r\n        const properties = Object.keys(input), toStringed = compatibleToString(input);\r\n        if(properties.length == 0){\r\n            if(toStringed != \"[object Object]\") return toStringed;\r\n            else return \"{}\";\r\n        }\r\n        else{\r\n            const input_ = cycle.decycle(input) as anyObject;\r\n            for(let i = 0; i < properties.length; i++){\r\n                const key = properties[i], value = input_[key], type = typeof value;\r\n                if(type == \"undefined\" || type == \"number\" || type == \"boolean\") addResult(value);\r\n                else if(type == \"string\") addResult(`\"${value}\"`); //字符串是带双引号的\r\n                else if(type == \"bigint\") addResult(value + \"n\");\r\n                else if(type == \"symbol\") addResult(value.toString()); //symbol不能隐式转换为字符串，又不能用in运算符\r\n                else if(type == \"function\") addResult(compatibleToString(value));\r\n                else if(type == \"object\") addResult(advancedStringify(value));\r\n                //else utils.generic.EE(\"?\"); 这个如果真走到了那世界可以毁灭了\r\n                if(i < properties.length - 1) result += \", \";\r\n                function addResult(input2 :any) :void{\r\n                    result += `${key}: ${input2}`;\r\n                }\r\n            }\r\n            result += \"}\";\r\n            return result;\r\n        }\r\n    }\r\n}\r\nexport function compatibleToString(input2 :object) :string{\r\n    //typeof undefined不能in\r\n    //typeof number™也不能in？？？那只能在前面兼容了\r\n    return \"toString\" in input2 ? input2.toString() : toString.call(input2);\r\n}","/* cycle.js 2021-05-31 Public Domain. NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK. This code should be minified before deployment. See https://www.crockford.com/jsmin.html. USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO NOT CONTROL.*/\n/* library of dynamic\n * dynamic ©2022 LJM12914. https://github.com/wheelsmake/dynamic\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\n*/\nimport * as utils from \"../../../utils/index\";\nimport * as lUtils from \"../utils/index\";\n/**Make a deep copy of an object or array, assuring that there is at most one instance of each object or array in the resulting structure. The duplicate references (which might be forming cycles) are replaced with an object of the form {\"$ref\": PATH} where the PATH is a JSONPath string that locates the first occurance.\n * \n * So,`var a = [];a[0] = a;return JSON.stringify(JSON.decycle(a));`produces the string '[{\"$ref\":\"$\"}]'.\n * \n * JSONPath is used to locate the unique object. $ indicates the top level of the object or array.\n * \n * [NUMBER] or [STRING] indicates a child element or property.*/\nexport function decycle(object :object) :object{\n    const objects = new WeakMap<object, string>(); //WeakMap：96.59%（2022.8.22）\n    return(function checkCycle(object :object, path :string){\n        if( //过滤阴间object\n            typeof object === \"object\"\n         && object !== null\n         && !(object instanceof Boolean)\n         && !(object instanceof Date)\n         && !(object instanceof Number)\n         && !(object instanceof RegExp)\n         && !(object instanceof String)\n        ){\n            const prev_path = objects.get(object);\n            //如果在存储中已经有了对应的唯一值，那么就存在循环引用…………………………？，返回$ref：那个值的路径\n            //fixed:仅当路径存在相同部分时，我们才能走回原点，这样才存在循环引用\n            if(prev_path !== undefined && path.indexOf(prev_path) != -1) return {$ref: prev_path};\n            else objects.set(object, path); //否则加入将这个值和路径加入存储\n            //进入对象或数组，递归\n            if(object instanceof Array){\n                const newObj :any[] = [];\n                for(let i = 0; i < object.length; i++) newObj[i] = checkCycle(object[i], path + \"[\" + i + \"]\");\n                return newObj;\n            }\n            else{\n                const newObj :anyObject = {}, keys = Object.keys(object);\n                if(keys.length != 0) for(let i = 0; i < keys.length; i++) newObj[keys[i]] = checkCycle((object as anyObject)[keys[i]], path + \"[\" + JSON.stringify(keys[i]) + \"]\");\n                else{\n                    const toStringed = lUtils.misc.compatibleToString(object);\n                    if(toStringed != \"[object Object]\") return object;\n                    //else return newObj;\n                }\n                return newObj;\n            }\n        }\n        else return object;\n    }(object, \"$\"));\n};\n/*export function retrocycle($: any){\n// Restore an object that was reduced by decycle. Members whose values are\n// objects of the form\n//      {$ref: PATH}\n// are replaced with references to the value found by the PATH. This will\n// restore cycles. The object will be mutated.\n\n// The eval function is used to locate the values described by a PATH. The\n// root object is kept in a $ variable. A regular expression is used to\n// assure that the PATH is extremely well formed. The regexp contains nested\n// * quantifiers. That has been known to have extremely bad performance\n// problems on some browsers for very long strings. A PATH is expected to be\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\n// Goessner's JSONPath.\n\n// So,\n//      var s = '[{\"$ref\":\"$\"}]';\n//      return JSON.retrocycle(JSON.parse(s));\n// produces an array containing a single element which is the array itself.\n    const px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\n    (function rez(value){\n// The rez function walks recursively through the object looking for $ref\n// properties. When it finds one that has a value that is a path, then it\n// replaces the $ref object with a reference to the value that is found by\n// the path.\n        if(value && typeof value === \"object\"){\n            if(Array.isArray(value)){\n                value.forEach((element, i)=>{\n                    if(typeof element === \"object\" && element !== null){\n                        const path = element.$ref;\n                        if(typeof path === \"string\" && px.test(path)) value[i] = eval(path);\n                        else rez(element);\n                    }\n                });\n            }\n            else{\n                Object.keys(value).forEach(key=>{\n                    const item = value[key];\n                    if(typeof item === \"object\" && item !== null){\n                        const path = item.$ref;\n                        if(typeof path === \"string\" && px.test(path)) value[key] = eval(path);\n                        else rez(item);\n                    }\n                });\n            }\n        }\n    })($);\n    return $;\n};*/","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n\r\n//开发模式\r\nconsole.info(\r\n`dynamic(dnJS) ©LJM12914. https://github.com/wheelsmake/dynamic\r\nYou are using the unminified build of dynamic. Make sure to use the minified build for production.`);\r\n\r\nconst\r\n//字符串重用\r\n    s :string[] = [\r\n        \"鬼片出现了！\",\r\n        \"Access to deleted property was blocked: \"\r\n    ],\r\n//HTML声明式语法设置（不喜欢目前语法的开发者可以fork后自己直接改动这里！）\r\n    HTMLDSLs = {\r\n        twoWayBinding :{\r\n            leftBracket: \"_:\",\r\n            rightBracket: \":_\"\r\n        },\r\n        oneWayBinding :{\r\n            leftBracket: \"_-\",\r\n            rightBracket: \"-_\"\r\n        },\r\n        attrAdditional: \":\" //这个玩意的位置配置不在这里，在#hydrate里面，懒得提出来了\r\n    },\r\n    twoWayBindingRegExp = new RegExp(`^${HTMLDSLs.twoWayBinding.leftBracket}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.twoWayBinding.rightBracket}$`),\r\n    oneWayBindingRegExp = new RegExp(`^${HTMLDSLs.oneWayBinding.leftBracket}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.oneWayBinding.rightBracket}$`),\r\n    //这个不使用\r\n    //nStwoWayBindingRegExp = new RegExp(`${HTMLDSLs.twoWayBinding.leftBracket}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.twoWayBinding.rightBracket}`, \"g\"),\r\n    nSoneWayBindingRegExp = new RegExp(`${HTMLDSLs.oneWayBinding.leftBracket}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.oneWayBinding.rightBracket}`, \"g\");\r\n\r\n\r\n//主类\r\nexport default class App{\r\n//#region 基本功能\r\n    constructor(rootNode :Elementy){\r\n        this.#rootNode = utils.arguments.reduceToElement(rootNode)!;\r\n        console.info(\"creating new dynamic instance with rootNode\", rootNode);\r\n        this.#initData();\r\n        this.#hydrate(this.#rootNode);\r\n        //不用观察自己对DOM的修改\r\n        this.#observer.observe(this.#rootNode, {\r\n            attributes: true,\r\n            attributeOldValue: true,\r\n            characterData: true,\r\n            characterDataOldValue: true,\r\n            childList: true,\r\n            subtree: true\r\n        });\r\n    }\r\n    #rootNode :Element;\r\n    get rootNode(){return this.#rootNode;}\r\n//#endregion\r\n\r\n//#region 数据管理\r\n    #data :dataObject = {};\r\n    //proxy虽然代理了#data这个dataObject，但它的表现其实就是一个典型的、完整的anyObject\r\n    #proxy :anyObject = {};\r\n    //proxy本身没有不可变性，必须再用一个data只读伪属性保护\r\n    get data(){return this.#proxy;} //class内部不要引用这个data！内部为什么不直接引用#proxy呢？？？？？\r\n    get _(){return this.#proxy;} //缩写\r\n    get __DEV_data__(){return this.#data;}\r\n    #initData(){\r\n        //note:sharpData === this.#data\r\n        this.#proxy = new Proxy(this.#data, {\r\n            get(sharpData :dataObject, property :string | symbol, proxy :dataObject) :any{\r\n                property = lUtils.misc.eliminateSymbol(property);\r\n                //console.log(\"get\", property);\r\n                //正常存在该属性\r\n                if(property in sharpData && !sharpData[property].deleted){\r\n                    let result :any;\r\n                    //如果是“计算”属性就“计算”它，获得返回值\r\n                    if(lUtils.data.isComputedProperty(sharpData[property])){\r\n                        result = (sharpData[property].value.bind(proxy))(proxy);\r\n                        sharpData[property].value\r\n                    }\r\n                    else result = sharpData[property].value;\r\n                    //不要在这边优化object显示，这边是有啥输出啥！人家传一个object进来，你给他一个string回去？？？正确的方法是在textContent替换中写object！\r\n                    return result;\r\n                }\r\n                //不用创建属性！\r\n                else if(!(property in sharpData)) return undefined;\r\n                //该属性已被删除fixed:这个不能放在没有该属性前，reading undefined警告\r\n                else if(sharpData[property].deleted) console.warn(`${s[1]}${property}.`);\r\n                else console.error(s[0], \"get\", property); //不可能有else了……？\r\n            },\r\n            set(sharpData :dataObject, property :string | symbol, newValue :unknown, proxy :dataObject) :boolean{\r\n                property = lUtils.misc.eliminateSymbol(property);\r\n                //console.log(\"set\", property, newValue);\r\n                //正常存在该属性\r\n                if(property in sharpData && !sharpData[property].deleted){\r\n                    //如果传入的是函数，那么就收集函数中需要的属性，将这些属性的shouldUpdate中推一个这个属性\r\n                    //`a.shouldUpdate[number] = \"b\"` 的意思是：当属性a发生改变时，要去更新b\r\n                    //更新b并不是运行一次b.value函数，而是去更新b.shouldExport，重新运行一遍这些方法，将DOM中的b更新\r\n                    //我们也要同样地去b.shouldUpdate里将它们的shouldExport运行了，因为它们的值也“应该”改变了\r\n                    //这是一个递归过程，一直从shouldUpdate下去，一直运行shouldExport\r\n                    if(typeof newValue == \"function\"){\r\n                        //todo:“计算”属性\r\n                    }\r\n                    const oldValue = sharpData[property].value;\r\n                    sharpData[property].value = newValue;\r\n                    if(oldValue !== newValue){ //要是前后相同，为什么还要更新呢？——嫖怪\r\n                        //更新依赖方法\r\n                        const exportInstances = sharpData[property].shouldExports, updates = sharpData[property].shouldUpdates;\r\n                        for(let i = 0; i < updates.length; i++){\r\n                            \r\n                        }\r\n                        for(let i = 0; i < exportInstances.length; i++){\r\n                            (exportInstances[i][0].bind(proxy))(exportInstances[i], oldValue);\r\n                        }\r\n                    }\r\n                }\r\n                //尚未有该属性，新建\r\n                else if(!(property in sharpData)){\r\n                    if(typeof newValue == \"function\"){\r\n                        //todo:“计算”属性\r\n                    }\r\n                    else if(typeof newValue == \"object\"){\r\n\r\n                    }\r\n                    sharpData[property] = lUtils.data.createData(newValue);\r\n                }\r\n                //该属性已被删除fixed:这个不能放在没有该属性前，reading undefined警告\r\n                else if(sharpData[property].deleted) console.warn(`${s[1]}${property}.`);\r\n                else console.error(s[0], \"set\", property); //不可能有else了\r\n                return true;\r\n            },\r\n            //用has拦截in运算没必要，因其不会导致#data状态的改变，并且in是可以完全正常使用的\r\n            //Proxy的defineProperty只会在Object.defineProperty走到，别听MDN的\r\n            //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/defineProperty#:~:text=proxy.property%3D%27value%27\r\n            //只要警告他们不要用Object.defineProperty往data里扔东西就好了\r\n            deleteProperty(sharpData :dataObject, property :string | symbol) :boolean{\r\n                //reviewed:不要真正删除而是标记删除\r\n                property = lUtils.misc.eliminateSymbol(property);\r\n                const exists = property in sharpData;\r\n                if(exists) sharpData[property].deleted = true;\r\n                return exists;\r\n            }\r\n        });\r\n    }\r\n    //这两个必须使用#data得到完整的data实例\r\n    addExport(dataProperty :string, func :exportFunc, target :Node) :shouldExportA{return lUtils.data.addExport(this.#proxy, this.#data[dataProperty], func, target);}\r\n    removeExport(dataProperty :string, func :string | exportFunc) :shouldExportA{return lUtils.data.removeExport(this.#data[dataProperty], func);}\r\n//#endregion\r\n\r\n//#region todo:实例内方法\r\n    #methods :functionObject = {};\r\n    addMethods(){\r\n\r\n    }\r\n    removeMethods(){\r\n\r\n    }\r\n//#endregion\r\n\r\n//#region HTML声明式语法\r\n    //外部访问\r\n    hydrate(node :Node) :void{\r\n        //不要扩展作用域\r\n        if(/*utils.element.isDescendant(node, this.#rootNode)*/this.#rootNode.contains(node)) this.#hydrate(node);\r\n        else utils.generic.E(\"node\", undefined, node, \"the input node must be a descendant of the rootNode\");\r\n    }\r\n    #hydrate(node :Node) :void{\r\n        if(node instanceof Element){\r\n            //hack:超级hack完美解决作用域内部元素on*事件必须访问全局App才能访问数据的问题\r\n            //给作用域内每个元素的data和_都弄上这个data，然后只要this一下就出来了！\r\n            const data = this.data;\r\n            Object.defineProperty(node, \"data\", {\r\n                configurable: false,\r\n                enumerable: true,\r\n                get(){return data;}\r\n            });\r\n            Object.defineProperty(node, \"_\", {\r\n                configurable: false,\r\n                enumerable: true,\r\n                get(){return data;}\r\n            });\r\n            //fixed:Element.attributes是一个实时集合，而我们在循环中有删除元素，会导致缺陷for循环！\r\n            const attrs = Array.from(node.attributes), children = Array.from(node.childNodes) as Node[];\r\n            for(let i = 0; i < attrs.length; i++){\r\n                //#region 关于attribute与property的讨论\r\n                /*important:fixed:-warning:对于某些attribute来说，它们本身只是一个默认值，想要获得真正的值需要访问节点的对应property！\r\n                但是我们无法知道哪些attribute有这种阴间问题，到时候一味更新attribute没更新到property就没用了\r\n                目前看了看标准和文档，来试图真正说清楚这个。\r\n                我们将property/attribute组合叫pa组合。\r\n                我们将 $0[property] = x会导致$0.getAttribute(\"property\") === x 称为 拥有完整的p->a同步。\r\n                我们将 $0.setAttribute(\"property\", x)会导致$0[property] === x 称为 拥有完整的a->p同步。\r\n                我们将拥有完整的p->a同步和拥有完整的a->p同步称为完全双向同步，拥有两者中任一种称为单向同步。\r\n                如果存在同步，但property的值需要改变，那么称为非同名同步。\r\n                pa组合一共有以下几种：\r\n                1. 同名且完全双向同步，如accept。\r\n                2. 不同名且完全双向同步，如value(a)和defaultValue(p)。\r\n                3. 不同名且不可能双向同步，因为两边的格式不同，如style。但是这种情况下浏览器已经做好了转换，可以近似视作第二种。\r\n                由此可见pa组合一定存在双向同步，这和whatwg.org的标准是完全相符的。\r\n                但是可能名字不同。这个名字不同问题很大，因为有的只是kebab转camel，有的整个都变了，如value->defaultValue，class->className。\r\n                并且有的不同组合的a和p存在一次性的同步，这个“一次性”发生在第一次加载页面（Gecko和IE）或每次刷新页面（chromium）\r\n                例如value(a)和value(p)，它们不是一个组合（value(a)和defaultValue(p)才是一对的），一次性同步方向为value(a)->value(p)。\r\n                important:我们的目的是：能够做到属性值与data双向同步，即修改属性值会触发data修改且触发data should*事件，修改data触发属性值的修改。\r\n                那么，有一个很好玩的方案：data是典型的引用/代理类型，属性(p)是标准JavaScript属性，那为什么不直接把属性(p)改成data呢？\r\n                哦，不行，属性(p)本质上是一个使用getter和setter的伪属性，不能变成其他值。\r\n                还有方案：用observer监控DOM（就是最开始的“上传”实现策略）。\r\n                但是observer只能监测attributes，对于没有与attribute组合的property它无能为力了。\r\n                所以，真的要放弃了吗……\r\n                fixme:我们目前只能做到specific处理，general处理等我再想想。\r\n                特殊处理限于class、<input>中的value和checked。style不用。\r\n                参考链接：\r\n                https://javascript.info/dom-attributes-and-properties#:~:text=But%20there%20are%20exclusions\r\n                https://stackoverflow.com/questions/57475325\r\n                https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes\r\n                */\r\n                //#endregion\r\n                //检查属性名和属性值，它们都要求全部是插值，不允许中途插值；其中属性值支持双向绑定\r\n                let name = attrs[i].name, value = attrs[i].value; //???:这里不能用var？不同次for之间居然能共享var变量？\r\n                if(name.match(twoWayBindingRegExp) || name.match(oneWayBindingRegExp)){\r\n                    //属性名双向绑定是不合理的，警告开发者\r\n                    if(name.match(twoWayBindingRegExp)) console.warn(`It's not rational to declare a two-way binding attribute name: ${name}, automatically treated as one-way binding. Use \"${HTMLDSLs.oneWayBinding.leftBracket}${name.substring(2, name.length - 2)}${HTMLDSLs.oneWayBinding.rightBracket}\" instead.`);\r\n                    //不允许双重动态attribute\r\n                    if(value.match(twoWayBindingRegExp) || value.match(oneWayBindingRegExp)) console.warn(\"Cannot set an attribute with both name and value dynamic. Dynamic will make only attribute name dynamic.\");\r\n                    const property = name.substring(2, name.length - 2);\r\n                    //更新attribute的名称，值不改变；但是本质上是删除旧attribute，添加新attribute；因此必须需要一个参数，否则无从得知是哪个attribute\r\n                    const __addedByDynamic__ :exportFunc = function(this :anyObject, exportInstance :exportInstance, oldValue :string){ //参数里放this不影响函数的参数\r\n                        const newValue = this[property];\r\n                        if(oldValue !== newValue){\r\n                            const thisNode = exportInstance[1]! as Element,\r\n                            valueOfAttr = thisNode.getAttribute(oldValue)!;\r\n                            //要先删除，因为setAttribute可能会出错，出错了就会多一个attribute\r\n                            //出错后再次设置数据属性的值时，如果成功设置了attr，attr值也会是null，因为上次没有成功，旧的attr值直接没了，这完全符合预期！\r\n                            thisNode.removeAttribute(oldValue);\r\n                            if(newValue !== \"\"){\r\n                                //警告开（我）发（自）者（己）不要传大写字母进属性名\r\n                                if(typeof newValue == \"string\" && newValue !== newValue.toLowerCase()) console.warn(`Attribute names are case insensitive, don't pass string with upper-case letters which may cause bugs: ${newValue}`);\r\n                                thisNode.setAttribute(newValue, valueOfAttr);\r\n                            }\r\n                            //else \"\"不是有效的属性名称，所以我们将它视为属性被动态删除了\r\n                        }\r\n                        //else return; //值没有改变，直接返回\r\n                    };\r\n                    //很不幸，由于更新时有值改变的检测，并且必须通过值来确定set哪个attr，我们没法依靠export，必须自己上阵干掉标识\r\n                    node.removeAttribute(name); //删除旧value\r\n                    //如果开发者没有赋值，那么插值标识将留下undefined，反正不要留下标识。这里是与Dynamic.new一样的同步操作，不存在覆盖开发者设置的值的问题！\r\n                    if(!(property in this.#proxy)) this.#proxy[property] = undefined; //创建属性\r\n                    //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                    lUtils.data.addExport(this.#proxy, this.#data[property], __addedByDynamic__, node);\r\n                    node.setAttribute(this.#proxy[property], value); //将value搬迁到新的attribute中\r\n                }\r\n                //如果name已经被处理了，那么就不处理value了，现在不允许双重动态attribute了\r\n                else if(value.match(twoWayBindingRegExp) || value.match(oneWayBindingRegExp)){ //其实双向绑定就是加了个补丁，可以一起\r\n                    const property = value.substring(2, value.length - 2);\r\n                    node.removeAttribute(name); //这个不会有任何问题，因为会立即set回去，如果带${HTMLDSLs.attrAdditional}会被set不带${HTMLDSLs.attrAdditional}的attr\r\n                    //检测规避属性\r\n                    if(name[name.length - 1] == HTMLDSLs.attrAdditional) name = name.substring(0, name.length - 1);\r\n                    //不要再改动name了，后面要用没有处理过default的name变量\r\n                    let name_default_processed = name, __addedByDynamic__ :exportFunc;\r\n                    //特殊处理a/p。这里实际上只需要处理完全不能通过attribute做到的东西，class反而是不能通过property（因其名字不同）做到的……\r\n                    if(\r\n                        (name_default_processed == \"value\" || name_default_processed == \"checked\")\r\n                     && node instanceof HTMLInputElement //避免其他元素上可能存在这些开发者自定义的属性，造成干扰\r\n                     && name_default_processed in node //这个东西感觉没啥作用，其实只是加个保险。检测是否存在对应property，似乎value真的在input的原型链上而不是它本身的属性\r\n                    ) __addedByDynamic__ = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                        (node as anyObject)[name_default_processed] = this[property];\r\n                    }\r\n                    else{\r\n                        //处理上一个if过滤掉的对称情况\r\n                        if(node instanceof HTMLInputElement){\r\n                            //快死了，乱转大写小写的\r\n                            if(name_default_processed == \"defaultvalue\" && \"defaultValue\" in node) name_default_processed = \"value\";\r\n                            else if(name_default_processed == \"defaultchecked\" && \"defaultChecked\" in node) name_default_processed = \"checked\";\r\n                        }\r\n                        __addedByDynamic__ = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                            const newValue = this[property];\r\n                            if(oldValue !== newValue){\r\n                                //我们将null视为属性被动态删除了\r\n                                if(newValue === null) node.removeAttribute(name_default_processed); //setAttribute删不掉\r\n                                else node.setAttribute(name_default_processed, newValue);\r\n                            } \r\n                            //else 值没有改变，直接返回\r\n                        }\r\n                    }\r\n                    //如果开发者没有赋值，那么插值标识将留下undefined，反正不要留下标识。这里是与Dynamic.new一样的同步操作，不存在覆盖开发者设置的值的问题！\r\n                    if(!(property in this.#proxy)) this.#proxy[property] = undefined; //创建属性\r\n                    //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                    lUtils.data.addExport(this.#proxy, this.#data[property], __addedByDynamic__, node);\r\n                    node.setAttribute(name_default_processed, this.#proxy[property]); //在这里不会自动创建property！\r\n                    if(value.match(twoWayBindingRegExp)){ //打个双向同步补丁\r\n                        //特别处理这几个东西，就是这里需要用到原始的name\r\n                        if(node instanceof HTMLInputElement){\r\n                            if(name == \"value\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) this.#proxy[property] = node.value;\r\n                                });\r\n                            }\r\n                            else if(name == \"checked\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) this.#proxy[property] = node.checked;\r\n                                });\r\n                            }\r\n                            //else if(name == \"defaultValue\") 不需要了，跟着下面去监听就行了\r\n                        }\r\n                        else{\r\n                            this.#aOProcessorStore.set(node, (record: MutationRecord)=>{\r\n                                if(\r\n                                    record.attributeName === name_default_processed\r\n                                //只有在attribute值和数据属性的值不一样的时候才需要同步，否则会导致无限同步\r\n                                 && node.getAttribute(record.attributeName!) !== this.#proxy[property]\r\n                                ) this.#proxy[property] = node.getAttribute(record.attributeName!);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                //else\r\n            }\r\n            //进入子节点\r\n            for(let i = 0; i < children.length; i++) this.#hydrate(children[i]);\r\n        }\r\n        else if(node instanceof Text){ //fixed:如果修改Element的textContent则会覆盖所有子元素，所以我们仅在文本节点上执行这边的代码\r\n            if(node.textContent){\r\n                //只有单向绑定支持模板，双向绑定是不支持的，必须全都是\r\n                const text = node.textContent, inserts = [...text.matchAll(nSoneWayBindingRegExp)];\r\n                //没有匹配到则为null，匹配到则[n]为${HTMLDSLs.oneWayBinding.leftBracket}example${HTMLDSLs.oneWayBinding.rightBracket}\r\n                if(inserts.length > 0){\r\n                    //我们先确定这一段文字中所有需要的属性，然后保存好这一段文字，然后给这些属性添加export方法\r\n                    //方法的具体内容是收集所有需要的属性，用保存好的文字作模板进行逐个属性的替换，最后塞回节点里\r\n                    //fixed:note:已经验证：chromium和Gecko都会在一个文本节点textContent被清空后直接删除这个文本节点。\r\n                    //succeed:通过exportInstance参数和一大堆定位常量，我们成功实现了文本节点被删除后的精确重建+正常更新！\r\n                    const offsets = [], properties = [],\r\n                          parent = node.parentNode!, nextNode = node.nextSibling; //不可能没有parentNode！https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentNode#%E5%A4%87%E6%B3%A8\r\n                    //收集数据并创建尚未创建的属性\r\n                    for(let i = 0; i < inserts.length; i++){\r\n                        const property = inserts[i][0].substring(2, inserts[i][0].length - 2);\r\n                        offsets.push(inserts[i].index);\r\n                        properties.push(property);\r\n                        //统一使用#proxy创建属性\r\n                        if(!(property in this.#proxy)) this.#proxy[property] = undefined; //this.#data[property] = lUtils.data.createData();\r\n                    }\r\n                    //构造并记录export方法\r\n                    const NRproperties = utils.generic.noRepeat(properties);\r\n                    const __addedByDynamic__ :exportFunc = function(this :anyObject, exportInstance :exportInstance){ //参数里放this不影响函数的参数\r\n                        let t = text; //为了保证它是值类型，node.textContent是引用类型，会变\r\n                        if(!document.contains(exportInstance[1]!)){ //弄一个新的文本节点出来，必定存在\r\n                            exportInstance[1] = document.createTextNode(text); //text是模板字符串，要用text才能replaceAll\r\n                            parent.insertBefore(exportInstance[1], nextNode);\r\n                        }\r\n                        let thisNode = exportInstance[1]!;\r\n                        for(let i = 0; i < NRproperties.length; i++){\r\n                            let data = this[NRproperties[i]];\r\n                            //fixed:见initData()->Proxy->set\r\n                            if(typeof data == \"object\") data = lUtils.misc.advancedStringify(data);\r\n                            t = t.replaceAll(`${HTMLDSLs.oneWayBinding.leftBracket}${NRproperties[i]}${HTMLDSLs.oneWayBinding.rightBracket}`, data);\r\n                        }\r\n                        //不修改innerText而是修改textContent，因为innerText会触发更多的浏览器绘制过程\r\n                        //测试：执行for(let i = 0;i < 1000; i++){$0.innerText += \"a\"}\r\n                        //innerText：144.42ms 每次都要触发一次重新计算样式——布局（强制自动重排）\r\n                        //textContent：4.6ms 最后一次设置后再进行重新计算样式——布局\r\n                        thisNode.textContent = t;\r\n                    }\r\n                    for(let i = 0; i < NRproperties.length; i++){\r\n                        //数据属性流程。如果开发者没有赋值，那么插值标识将留下undefined，反正不要留下标识。这里是与Dynamic.new一样的同步操作，不存在覆盖开发者设置的值的问题！\r\n                        if(!(NRproperties[i] in this.#proxy)) this.#proxy[NRproperties[i]] = undefined; //创建属性\r\n                        //有可能是之前遍历的节点也插入了这个属性，我们不要随便赋值，只需要添加export即可，会自动引发的\r\n                        lUtils.data.addExport(this.#proxy, this.#data[NRproperties[i]], __addedByDynamic__, node);\r\n                    }\r\n                }\r\n                //textContent双向绑定\r\n                else if(text.match(twoWayBindingRegExp)){\r\n                    if( //fuck:我要爆粗口了！TS没十年脑溢血写不出来啊！你™parentElement返回类型HTMLElement？？？\r\n                        //有生之年我居然在判断HTMLElement instanceof HTMLElement！\r\n                        //并且ts还号称要平衡生产力和准确性，不修这个问题！2015年的老issue了https://github.com/microsoft/TypeScript/issues/4689#issuecomment-146324456\r\n                        !(node.parentElement! instanceof HTMLElement)\r\n                    ) console.warn(\"It's no use adding a two-way binding insert to an SVGElement, but dynamic will continue anyway.\");\r\n                    //todo:\r\n                }\r\n            }\r\n            //else 一般不可能走到这浏览器就给你删了\r\n        }\r\n        //else console.error(s[0], node); //这里没有鬼片，注释节点会走到这里\r\n    }\r\n//#endregion\r\n\r\n//#region DOM监控\r\n    //WeakMap：96.59%（2022.8.22）\r\n    #aOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    #dOProcessorStore = new WeakMap<Node, MRProcessorFn>();\r\n    #cOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    //简单的DOM监控回调机制，全看对面MRProcessorFn设计得如何\r\n    #observer :MutationObserver = new MutationObserver((records :MutationRecord[])=>{\r\n        for(let i = 0; i < records.length; i++){\r\n            const record = records[i], type = record.type;\r\n            console.log(record);\r\n            //既然有attribute那肯定是Element\r\n            if(type == \"attributes\" && this.#aOProcessorStore.has(record.target as Element)) this.#aOProcessorStore.get(record.target as Element)!(record);\r\n            else if(type == \"characterData\" && this.#dOProcessorStore.has(record.target)) this.#dOProcessorStore.get(record.target)!(record);\r\n            //既然有childList那肯定是Element\r\n            else if(type == \"childList\" && this.#cOProcessorStore.has(record.target as Element)) this.#cOProcessorStore.get(record.target as Element)!(record);\r\n            //else\r\n        }\r\n    });\r\n//#endregion\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\n/**一定会返回Element，void为报错hack*/\r\nexport function reduceToElement(input :Elementy) :Element | void{\r\n    if(input instanceof Element) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el as Element;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\"); //fixed:现在不会走到new Element()那儿了\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n/*export default class Template{\r\n    \r\n}*/\r\nexport function register(){\r\n\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function getSearch() :SSkvObject | null{\r\n    var s = location.search;\r\n    if(s != \"\"){\r\n        s = s.substring(1);\r\n        const result :SSkvObject = {};\r\n        s.split(\"&\").forEach(value=>{\r\n            const sp = value.split(\"=\");\r\n            result[sp[0]] = sp[1];\r\n        });\r\n        return result;\r\n    }\r\n    else return null;\r\n}\r\nexport function getHash() :string{\r\n    return location.hash.substring(1);\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function add(){\r\n    //todo:\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n\r\n//分文件开发\r\nimport App from \"./app\";\r\nimport * as template from \"./template\";\r\nimport * as spa from \"./spa\";\r\nimport * as manifest from \"./manifest\";\r\n\r\n\r\n//禁用开发者工具的hack变量\r\nconst cI = clearInterval;\r\nvar dtInterval :number;\r\n//禁用开发者工具（不推荐，因此在API指引里没写）\r\nfunction __disableDevTools__() :void{\r\n    dtInterval = (()=>{\r\n        return setInterval(()=>{\r\n            debugger;\r\n        }, 20) as unknown as number; //怎么默认在NodeJS环境下呢？？？\r\n    })();\r\n    //hack clearInterval，让它不清除我们的这个\r\n    //Proxy中毒太深了，Proxy只在一大堆对象的代理上有性能优势，就这一个还不如用function\r\n    (clearInterval as any) = (id: number | undefined) :void=>{\r\n        if(id != dtInterval) cI.call(window, id);\r\n    }\r\n    /*(clearInterval as any) = new Proxy(clearInterval, {\r\n        apply(target, thisArg, argArray){\r\n            if(argArray[0] != dtInterval) return Reflect.apply(target, thisArg, argArray);\r\n        }\r\n    });*/\r\n}\r\nfunction __enableDevTools__() :void{\r\n    (clearInterval as any) = cI;\r\n    clearInterval(dtInterval);\r\n}\r\n\r\n//构造导出对象\r\nfunction Dynamic(rootNode :Elementy){return new App(rootNode);}\r\n((obj :anyObject)=>{\r\n    for(let i in obj) (Dynamic as anyObject)[i] = obj[i];\r\n})({\r\n    //引入模块\r\n    template, spa, manifest,\r\n    //工具方法\r\n    e(s: string, scope?: Element | Document) :Node | Node[]{return utils.element.e(s, scope);},\r\n    render(args :{\r\n        HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[],\r\n        element :Element, insertAfter? :boolean, append? :boolean\r\n    }) :Node[]{return utils.element.render(args.HTML, args.element, args.insertAfter, args.append);},\r\n    toHTML(HTML :string) :Node[]{return utils.element.toHTML(HTML)},\r\n    hatch(element :Element, remove? :boolean) :Node[]{return utils.element.hatch(element, remove);},\r\n    compose(){}, //todo:\r\n    //hack\r\n    __disableDevTools__,\r\n    __enableDevTools__,\r\n    constructor(){console.log(\"a\");}\r\n});\r\n\r\n//导出\r\nutils.generic.constantize(Dynamic);\r\nexport default Dynamic;","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport Dynamic from \"./dynamic.export\";\r\n//fixed:当作模块使用的时候不需要弄到全局作用域，所以将这个东西抽出来了\r\nObject.defineProperty(window, \"Dynamic\", {\r\n    configurable: false,\r\n    writable: false,\r\n    enumerable: true,\r\n    value: Dynamic\r\n});"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","precisePop","ele","array","indexOf","splice","E","argument","type","reason","undefined","Error","console","error","e","s","scope","Element","document","a","querySelectorAll","length","match","Array","from","toHTML","HTML","createElement","innerHTML","el","nodes","i","childNodes","cloneNode","getInnerNodesClone","render","element","insertAfter","append","parentElement","message","html","Node","HTMLCollection","NodeList","item","Rhtml","reverse","parent","prepend","nextSibling","insertBefore","addExport","proxy","dataInstance","func","target","sE","shouldExports","toString","isDuplicated","warn","instance","push","bind","isComputedProperty","data","eliminateSymbol","property","advancedStringify","input","result","properties","keys","toStringed","compatibleToString","input_","object","objects","WeakMap","checkCycle","path","Boolean","Date","Number","RegExp","String","prev_path","$ref","set","newObj","JSON","stringify","addResult","input2","HTMLDSLs","leftBracket","rightBracket","twoWayBindingRegExp","oneWayBindingRegExp","nSoneWayBindingRegExp","App","constructor","rootNode","MutationObserver","records","record","this","has","observe","attributes","attributeOldValue","characterData","characterDataOldValue","childList","subtree","_","__DEV_data__","dataProperty","removeExport","name","addMethods","removeMethods","hydrate","node","contains","register","getSearch","location","search","substring","split","forEach","sp","getHash","hash","add","Proxy","sharpData","deleted","newValue","oldValue","exportInstances","updates","shouldUpdates","shouldUpdate","shouldExport","cache","deleteProperty","exists","configurable","attrs","children","__addedByDynamic__","exportInstance","thisNode","valueOfAttr","getAttribute","removeAttribute","toLowerCase","setAttribute","name_default_processed","HTMLInputElement","addEventListener","checked","attributeName","Text","textContent","text","inserts","matchAll","offsets","parentNode","nextNode","index","NRproperties","Set","t","createTextNode","replaceAll","HTMLElement","cI","clearInterval","dtInterval","Dynamic","template","spa","manifest","args","hatch","remove","par","compose","__disableDevTools__","setInterval","id","window","__enableDevTools__","constantize","freeze","writable"],"sourceRoot":""}