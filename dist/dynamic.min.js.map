{"version":3,"file":"dynamic.min.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///../utils/generic.ts","webpack:///../utils/element.ts","webpack:///../utils/devTools.ts","webpack:///./src/utils/data.ts","webpack:///./src/utils/misc.ts","webpack:///./src/libs/cycle.ts","webpack:///./src/app.ts","webpack:///./src/template.ts","webpack:///./src/spa.ts","webpack:///./src/manifest.ts","webpack:///./src/dynamic.export.ts","webpack:///../utils/arguments.ts","webpack:///./src/dynamic.defineGlobal.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function randoma2Z(length :number) :string{ //52\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 52);\r\n        if(r > 25) s += String.fromCharCode(r + 71);\r\n        else s += String.fromCharCode(r + 65);\r\n    }\r\n    return s;\r\n}\r\nexport function randoma2z029(length :number) :string{ //36\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 36);\r\n        if(r < 10) s += r;\r\n        else s += String.fromCharCode(r + 87);\r\n    }\r\n    return s;\r\n}\r\nexport function precisePop<T>(ele :T, array :any[]) :T | null{\r\n    if(array.indexOf(ele) === -1) return null;\r\n    return array.splice(array.indexOf(ele), 1)[0];\r\n}\r\n//递归冻结对象\r\nexport function constantize(obj :anyObject) :void{\r\n    Object.freeze(obj);\r\n    for(let i = 0; i < Object.keys(obj).length; i++) if(typeof obj[Object.keys(obj)[i]] == \"object\") constantize(obj[Object.keys(obj)[i]]);\r\n}\r\nexport function E(argument :string, type? :string, value? :any, reason? :string) :never{\r\n    if(argument === undefined) throw new Error(\"An error occured.\");\r\n    else{\r\n        console.error(\"ERROR INFO: argument\", argument, \",type\", type, \",value\", value, \",reason\", reason); //为了拿到真正的value，其他类型toString后啥信息都没了\r\n        throw new Error(`Argument '${argument}' ${type ? `should be a(an) ${type}` : \"is invalid\"}${reason ? `, reason: ${reason}` : \"\"}${value ? `, got ${value}` : \"\"}.`);\r\n    }\r\n}\r\nexport function EE(message :any) :never{throw new Error(message);}\r\nexport function repeat<T>(item :T, count :number) :T[]{\r\n    if(typeof count != \"number\" || count < 1) utils.generic.E(\"count\", \"integer bigger than 0\", count);\r\n    return Array(count).fill(item, 0, count);\r\n}\r\nexport function noRepeat<T>(input :T[]) :T[]{\r\n    return Array.from(new Set(input)); //Set可是连IE11都支持的东西啊\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function e(s :string, scope? :Element | Document) :Node[] | Node{\r\n    if(scope === undefined || !(scope instanceof Element)) scope = document;\r\n        let a :NodeList = scope.querySelectorAll(s);\r\n        if(!a.length) return [];\r\n        //note:当一个页面存在相同ID元素时不会走这里，而会返回数组，因为说好了是querySelectorAll了并且本来就不应该有重复ID，不能怪我啊\r\n        if(a.length == 1 && s.match(/^.*#[^\\s]*$/)) return a[0];\r\n        else return Array.from(a);\r\n}\r\n/**@deprecated use `Node.contains` instead.*/\r\nexport function isDescendant(possibleDescendant :Node, possibleParent :Node) :boolean{\r\n    return possibleParent.contains(possibleDescendant);\r\n    /*while(\r\n        possibleDescendant instanceof Text\r\n     || (possibleDescendant instanceof Element && possibleDescendant.tagName != \"HTML\")\r\n    ){\r\n        possibleDescendant = possibleDescendant.parentNode! as Element;\r\n        if(possibleDescendant === possibleParent) return true; \r\n    }\r\n    return false;*/\r\n}\r\nexport function isInDocument(node :Node) :boolean{\r\n    return ((e(\"html\") as Node[])[0]).contains(node);\r\n    //return isDescendant(element, (e(\"html\") as Node[])[0] as Element);\r\n}\r\nexport function isChild(node :Node, target :Element) :boolean{\r\n    return Array.from(target.childNodes).indexOf(node as ChildNode) != -1;\r\n    /*const children = target.childNodes;\r\n    for(let i = 0; i < children.length; i++) if(element === children[i]) return true;\r\n    return false;*/\r\n}\r\nexport function toHTML(HTML :string) :Node[]{\r\n    if(HTML === \"\" || typeof HTML != \"string\") utils.generic.E(\"HTML\", \"string\", HTML);\r\n    const ele = document.createElement(\"div\");\r\n    ele.innerHTML = HTML;\r\n    return getInnerNodesClone(ele);\r\n}\r\nexport function getInnerNodesClone(el :Node) :Node[]{\r\n    var nodes :Node[] = [];\r\n    for(let i = 0; i < el.childNodes.length; i++) nodes[i] = el.childNodes[i].cloneNode(true);\r\n    return nodes;\r\n}\r\n//剥壳器\r\nexport function hatch(element :Element, remove? :boolean) :Node[]{\r\n    //note:Nodelist类型会实时同步造成不稳定的for循环，必须转换为Node[]！\r\n    const par = element.parentElement!, children :Node[] = Array.from(element.childNodes);\r\n    for(let i = 0; i < children.length; i++) par.insertBefore(children[i], element);\r\n    if(remove === true) element.remove();\r\n    return children;\r\n}\r\n//fixme:这个方法特异性太强了吧，能不能不要放在这里？\r\n//最终渲染方法，老祖宗求你别出bug\r\nexport function render(\r\n    HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[],\r\n    element :Element,\r\n    insertAfter? :boolean,\r\n    append? :boolean\r\n) :Node[]{\r\n    if(element.parentElement === null) utils.generic.EE(\"cannot render by '<html>' element, since it's root of document.\");\r\n    var html :Node[] = [];\r\n    if(typeof HTML == \"string\") html = toHTML(HTML);\r\n    else if(HTML instanceof Element || HTML instanceof Node) html[0] = HTML.cloneNode(true);\r\n    else if(HTML instanceof HTMLCollection || HTML instanceof NodeList) for(let i = 0; i < HTML.length; i++) html[i] = HTML.item(i)!.cloneNode(true);\r\n    else html = HTML;\r\n    const Rhtml = [...html].reverse(), parent = element.parentElement;\r\n    if(append === true) for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    else if(append === false) for(let i = 0; i < Rhtml.length; i++) element.prepend(Rhtml[i]);\r\n    else if(insertAfter === true){\r\n        if(!element.nextSibling) for(let i = 0; i < Rhtml.length; i++) parent!.append(Rhtml[i]);\r\n        else for(let i = 0; i < Rhtml.length; i++) parent!.insertBefore(Rhtml[i], element.nextSibling);\r\n    }\r\n    else if(insertAfter === false) for(let i = 0; i < html.length; i++) parent!.insertBefore(html[i], element);\r\n    else for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    //todo:加入作用域\r\n    return html;\r\n}\r\n/****!PURE 非纯函数**\r\n * \r\n * 检测某个文本节点是否为垃圾文本节点（即缩进造成的文本节点）\r\n * \r\n * 这种文本节点会造成 vDOM 大小明显变大，必须处理\r\n * \r\n * 如果全部垃圾，那么就直接删除这个节点并返回 `null`\r\n * \r\n * 如果不完全垃圾，那么删除垃圾部分并返回剩下的 `textContent`\r\n * \r\n * 如果没有垃圾或**被判定为豁免节点**，那么直接返回 `textContent`\r\n */\r\n export function processNLIText(textNode :Text) :string | null{\r\n    //fixme:存在末尾\\n文本节点被浏览器自动加回去的问题（但并未影响vDOM）\r\n    const textContent = textNode.textContent!,\r\n          //这个是用来标记原字符串是否需要处理的\r\n          signContent = textContent.replace(/\\n\\s*/g, \"\"), //只有\\n也要删\r\n          parent = textNode.parentElement as Element; //replace不改动原字符串\r\n    //排除可编辑内容的元素的内容\r\n    const des = document.designMode;\r\n    if(\r\n        (parent !== null && parent.tagName == \"TEXTAREA\")\r\n     || (parent instanceof HTMLElement && parent.isContentEditable)\r\n     || (des == \"on\" || des == \"ON\" /*|| des == \"inherit\"*/) //inherit基本只出现在IE，不管它\r\n    ) return textContent;\r\n    else{\r\n        if(signContent === \"\"){ //完全就是垃圾节点\r\n            textNode.remove();\r\n            return null;\r\n        }\r\n        else if(signContent !== textContent){ //部分垃圾\r\n            textNode.textContent = textContent.replace(/\\n\\s*/g, \" \"); //更新文本节点，插入空格，保持视觉效果\r\n            return textNode.textContent; //fixed:signContent和textContent都不一样，干嘛返回signContent啊\r\n        }\r\n        else return textContent; //没有垃圾\r\n    }\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\n//禁用开发者工具的hack变量\r\nconst cI = clearInterval;\r\nexport default class devTools{\r\n    #dtInterval :number = 0;\r\n    constructor(){\r\n        this.disable();\r\n    }\r\n    enable() :void{\r\n        (clearInterval as any) = cI;\r\n        clearInterval(this.#dtInterval);\r\n    }\r\n    disable() :void{\r\n        if(clearInterval !== cI) utils.generic.EE(\"DevTools has been disabled.\");\r\n        this.#dtInterval = (()=>{\r\n            return setInterval(()=>{\r\n                debugger;\r\n            }, 20) as unknown as number; //怎么默认在NodeJS环境下呢？？？\r\n        })();\r\n        //hack clearInterval，让它不清除我们的这个 \r\n        (clearInterval as any) = (id :number | undefined) :void=>{\r\n            if(id != this.#dtInterval) cI.call(window, id);\r\n        }\r\n    }\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nconst FtoString = Function.prototype.toString;\r\n/**这里只负责创建对象并赋值，不负责任何值处理！*/\r\nexport function createData<T>(\r\n    value? :T,\r\n    shouldUpdate? :shouldUpdateA,\r\n    shouldExport? :shouldExportA\r\n) :data<T>{\r\n    const result :data<T> = {\r\n        value,\r\n        //deleted: false,\r\n        shouldUpdates: shouldUpdate || [],\r\n        shouldExports: shouldExport || []\r\n    }\r\n    if(typeof result.value == \"function\") result.cache = undefined;\r\n    return result;\r\n}\r\n/**这里如果添加成功会自动引发一次针对性的export*/\r\nexport function addExport<T>(proxy :anyObject, dataInstance :data<T>, func :exportFunc, target? :Node) :shouldExportA{\r\n    const sE = dataInstance.shouldExports;\r\n    checkArrowFunction(func);\r\n    //检测shouldExport里是不是已经有了完全相同的函数。很不幸，由于添加了target，我们需要手动遍历数组了\r\n    //important:这里的函数还是原函数，不能bind，不然后面查重就失效了，我们等到用的时候再bind也不迟，并且分析函数还需要bind不同的东西\r\n    let isDuplicated = false;\r\n    for(let i = 0; i < sE.length; i++) if(sE[i][0] === func){\r\n        isDuplicated = true;\r\n        break;\r\n    }\r\n    if(isDuplicated) console.warn(\"Duplicated function\", func, \"is blocked being added to data\", dataInstance);\r\n    else{\r\n        const exportInstance :exportInstance = [func, target, false];\r\n        sE.push(exportInstance);\r\n        //在这里会立即引发一次针对性的export，oldValue与现在的value相同\r\n        //内置export方法大部分已经通过对比value和oldValue过滤掉了这次调用（但不能完全过滤）\r\n        func.call(proxy, exportInstance, dataInstance.value);\r\n    }\r\n    //不要让外部获取真正的引用地址\r\n    return [...sE];\r\n}\r\n/**检测函数是否是箭头函数。箭头函数拿不到this，一定会出错*/\r\nexport function checkArrowFunction(func :Function) :void{\r\n    if(FtoString.call(func).match(/^\\([^\\(\\)]*\\)[\\s]*=>/)) utils.generic.E(\"func\", undefined, func, \"this function must not be an arrow function\");\r\n}\r\nexport function removeExport<T>(dataInstance :data<T>, func :string | exportFunc) :shouldExportA{\r\n    const sE = dataInstance.shouldExports;\r\n    if(typeof func == \"string\"){\r\n        if(func == \"\") console.warn(\"Operation blocked trying to remove ALL annoymous functions. Use the function itself for argument instead.\");\r\n        //注意这里会删除所有同名函数！\r\n        else for(let i = 0; i < sE.length; i++) if(sE[i][0].name === func) utils.generic.precisePop(sE[i], sE);\r\n    }\r\n    //由于添加了target，这里需要遍历数组\r\n    else if(typeof func == \"function\") for(let i = 0; i < sE.length; i++) if(sE[i][0] === func) utils.generic.precisePop(sE[i], sE); //不是exportFunc没关系；precisePop已经处理了-1\r\n    else utils.generic.E(\"func\", \"string | exportFunc\", func);\r\n    //不要让外部获取真正的引用地址\r\n    return [...sE];\r\n}\r\n/**@deprecated return typeof data.value == \"function\";*/\r\nexport function isComputedProperty<T>(data :data<T>) :boolean{\r\n    return typeof data.value == \"function\";\r\n}\r\n/**静态分析目标函数访问了哪些this属性，不要对此寄予厚望！*/\r\nexport function detectShouldUpdate(string :string) :shouldUpdateA{\r\n    const inQuote = {double: false, single: false, reversed: false}, result = [];\r\n    var resultAdding = false, subCursor = 0;\r\n    for(let i = 0; i < string.length; i++){\r\n        if(string[i] == \"\\\\n\"){\r\n            inQuote.double = false;\r\n            inQuote.single = false;\r\n        }\r\n        if(string[i] == \"`\" && !inQuote.single && !inQuote.double) inQuote.reversed = !inQuote.reversed;\r\n        if(string[i] == '\"' && !inQuote.single && !inQuote.reversed) inQuote.double = !inQuote.double;\r\n        if(string[i] == \"'\" && !inQuote.double && !inQuote.reversed) inQuote.single = !inQuote.single;\r\n        //if(inQuote.reversed && string[i] == \"$\" && string[i + 1] == \"{\") processTemplate(i); //todo:字符串插值\r\n        //console.log(string.substring(i - 5, i+5), inQuote);\r\n        //if(string[i] == \"]\" && subCursor != 0 && !inQuote.single && !inQuote.double && !inQuote.reversed){\r\n            //result.push(string.substring(subCursor, i - 2));\r\n            //subCursor = 0;\r\n        //}\r\n        if(!string[i].match(/[\\w$]/) && subCursor != 0 && !inQuote.single && !inQuote.double && !inQuote.reversed){\r\n            //console.log(string.substring(subCursor - 5, i + 5), string[subCursor], string[i]);\r\n            result.push(string.substring(subCursor, i));\r\n            subCursor = 0;\r\n        }\r\n        if(!inQuote.single && !inQuote.double && !inQuote.reversed \r\n         && string[i] == \"t\" && string[i + 1] == \"h\" && string[i + 2] == \"i\" && string[i + 3] == \"s\"\r\n         && string[i + 4] == \".\" //不支持[]使用变量来访问this，因为可能引用了完全不可能知道的外部变量\r\n        ){\r\n            subCursor = i + 5;\r\n            i += 4; //跳过this.，不然在.那里就会出来\r\n        }\r\n    }\r\n    return utils.generic.noRepeat(result);\r\n    function processTemplate(i :number){\r\n        //todo:\r\n    }\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nimport * as cycle from \"../libs/cycle\";\r\n/**@deprecated 请使用 `property :string` 强制设定类型*/\r\nexport function eliminateSymbol(property :string | Symbol) :string{\r\n    if(typeof property == \"symbol\") utils.generic.E(property.toString(), \"string\", property,  \"index of Dynamic.data must not be a Symbol\");\r\n    return property as string;\r\n}\r\nconst toString = Object.prototype.toString;\r\n/**Not `JSON.stringify`, more than `JSON.stringify`.*/\r\nexport function advancedStringify(input :object) :string{\r\n    if(typeof input != \"object\") utils.generic.E(\"input\", \"object\", input);\r\n    //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#%E5%BC%82%E5%B8%B8\r\n    //用这个记录事后将不应该加双引号的类型去除双引号，避免如\"undefined\"（typeof string）和undefined（typeof undefined）都变成\"undefined\"的情况\r\n    //const patchList :[string[], string[], object[]] = [[], [], []];\r\n    if(input === null) return \"null\"; //不要{}了\r\n    else{\r\n        let result :string = \"{\";\r\n        //我们只对元素本身的、可枚举的属性进行提取，即Object.keys得到的东西。\r\n        const properties = Object.keys(input), toStringed = compatibleToString(input);\r\n        if(properties.length == 0){\r\n            if(toStringed != \"[object Object]\") return toStringed;\r\n            else return \"{}\";\r\n        }\r\n        else{\r\n            const input_ = cycle.decycle(input) as anyObject;\r\n            for(let i = 0; i < properties.length; i++){\r\n                const key = properties[i], value = input_[key], type = typeof value;\r\n                if(type == \"undefined\" || type == \"number\" || type == \"boolean\") addResult(value);\r\n                else if(type == \"string\") addResult(`\"${value}\"`); //字符串是带双引号的\r\n                else if(type == \"bigint\") addResult(value + \"n\");\r\n                else if(type == \"symbol\") addResult(value.toString()); //symbol不能隐式转换为字符串，又不能用in运算符\r\n                else if(type == \"function\") addResult(compatibleToString(value));\r\n                else if(type == \"object\") addResult(advancedStringify(value));\r\n                //else utils.generic.EE(\"?\"); 这个如果真走到了那世界可以毁灭了\r\n                if(i < properties.length - 1) result += \", \";\r\n                function addResult(input2 :any) :void{\r\n                    result += `${key}: ${input2}`;\r\n                }\r\n            }\r\n            result += \"}\";\r\n            return result;\r\n        }\r\n    }\r\n}\r\nexport function compatibleToString(input :object) :string{\r\n    //typeof undefined不能in\r\n    //typeof number™也不能in？？？那只能在前面兼容了\r\n    return \"toString\" in input ? input.toString() : toString.call(input);\r\n}\r\nexport function noErrorDefineProperties(obj :object, properties :PropertyDescriptorMap) :void{\r\n    for(let i in properties) if(!(i in obj)) Object.defineProperty(obj, i, properties[i]);\r\n}","/* cycle.js 2021-05-31 Public Domain. NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK. This code should be minified before deployment. See https://www.crockford.com/jsmin.html. USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO NOT CONTROL.*/\r\n/* library of dynamic\r\n * dynamic ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"../utils/index\";\r\n/**Make a deep copy of an object or array, assuring that there is at most one instance of each object or array in the resulting structure. The duplicate references (which might be forming cycles) are replaced with an object of the form {\"$ref\": PATH} where the PATH is a JSONPath string that locates the first occurance.\r\n * \r\n * So,`var a = [];a[0] = a;return JSON.stringify(JSON.decycle(a));`produces the string '[{\"$ref\":\"$\"}]'.\r\n * \r\n * JSONPath is used to locate the unique object. $ indicates the top level of the object or array.\r\n * \r\n * [NUMBER] or [STRING] indicates a child element or property.*/\r\nexport function decycle(object :object) :object{\r\n    const objects = new WeakMap<object, string>(); //WeakMap：96.59%（2022.8.22）\r\n    return(function checkCycle(object :object, path :string){\r\n        if( //过滤阴间object\r\n            typeof object === \"object\"\r\n         && object !== null\r\n         && !(object instanceof Boolean)\r\n         && !(object instanceof Date)\r\n         && !(object instanceof Number)\r\n         && !(object instanceof RegExp)\r\n         && !(object instanceof String)\r\n        ){\r\n            const prev_path = objects.get(object);\r\n            //如果在存储中已经有了对应的唯一值，那么就存在循环引用…………………………？，返回$ref：那个值的路径\r\n            //fixed:仅当路径存在相同部分时，我们才能走回原点，这样才存在循环引用\r\n            if(prev_path !== undefined && path.indexOf(prev_path) != -1) return {$ref: prev_path};\r\n            else objects.set(object, path); //否则加入将这个值和路径加入存储\r\n            //进入对象或数组，递归\r\n            if(object instanceof Array){\r\n                const newObj :any[] = [];\r\n                for(let i = 0; i < object.length; i++) newObj[i] = checkCycle(object[i], path + \"[\" + i + \"]\");\r\n                return newObj;\r\n            }\r\n            else{\r\n                const newObj :anyObject = {}, keys = Object.keys(object);\r\n                if(keys.length != 0) for(let i = 0; i < keys.length; i++) newObj[keys[i]] = checkCycle((object as anyObject)[keys[i]], path + \"[\" + JSON.stringify(keys[i]) + \"]\");\r\n                else{\r\n                    const toStringed = lUtils.misc.compatibleToString(object);\r\n                    if(toStringed != \"[object Object]\") return object;\r\n                    //else return newObj;\r\n                }\r\n                return newObj;\r\n            }\r\n        }\r\n        else return object;\r\n    }(object, \"$\"));\r\n};\r\n/*export function retrocycle($: any){\r\n// Restore an object that was reduced by decycle. Members whose values are\r\n// objects of the form\r\n//      {$ref: PATH}\r\n// are replaced with references to the value found by the PATH. This will\r\n// restore cycles. The object will be mutated.\r\n\r\n// The eval function is used to locate the values described by a PATH. The\r\n// root object is kept in a $ variable. A regular expression is used to\r\n// assure that the PATH is extremely well formed. The regexp contains nested\r\n// * quantifiers. That has been known to have extremely bad performance\r\n// problems on some browsers for very long strings. A PATH is expected to be\r\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\r\n// Goessner's JSONPath.\r\n\r\n// So,\r\n//      var s = '[{\"$ref\":\"$\"}]';\r\n//      return JSON.retrocycle(JSON.parse(s));\r\n// produces an array containing a single element which is the array itself.\r\n    const px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\r\n    (function rez(value){\r\n// The rez function walks recursively through the object looking for $ref\r\n// properties. When it finds one that has a value that is a path, then it\r\n// replaces the $ref object with a reference to the value that is found by\r\n// the path.\r\n        if(value && typeof value === \"object\"){\r\n            if(Array.isArray(value)){\r\n                value.forEach((element, i)=>{\r\n                    if(typeof element === \"object\" && element !== null){\r\n                        const path = element.$ref;\r\n                        if(typeof path === \"string\" && px.test(path)) value[i] = eval(path);\r\n                        else rez(element);\r\n                    }\r\n                });\r\n            }\r\n            else{\r\n                Object.keys(value).forEach(key=>{\r\n                    const item = value[key];\r\n                    if(typeof item === \"object\" && item !== null){\r\n                        const path = item.$ref;\r\n                        if(typeof path === \"string\" && px.test(path)) value[key] = eval(path);\r\n                        else rez(item);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    })($);\r\n    return $;\r\n};*/","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nconst version = \"2.2.0\";\r\n\r\n//开发模式\r\nconsole.info(\r\n    `dynamic(dnJS) v${version} ©LJM12914. https://github.com/wheelsmake/dynamic\r\n    You are using the unminified build of dynamic. Make sure to use the minified build for production.`);\r\n\r\nconst\r\n//HTML声明式语法\r\n    DSL = {\r\n        two: {\r\n            l: \"_:\",\r\n            r: \":_\"\r\n        },\r\n        one: {\r\n            l: \"_-\",\r\n            r: \"-_\"\r\n        },\r\n        attr: \":\" //这个玩意的位置配置不在这里，在hydrate里面，懒得提出来了\r\n    },\r\n    twoRegExp = new RegExp(`^${DSL.two.l}[a-zA-Z$_][\\\\w$]*${DSL.two.r}$`),\r\n    oneRegExp = new RegExp(`^${DSL.one.l}[a-zA-Z$_][\\\\w$]*${DSL.one.r}$`),\r\n    /**这个是用来检查开发者的错误的*/\r\n    multiTwoRegExp = new RegExp(`${DSL.two.l}[a-zA-Z$_][\\\\w$]*${DSL.two.r}`, \"g\"),\r\n    multiOneRegExp = new RegExp(`${DSL.one.l}[a-zA-Z$_][\\\\w$]*${DSL.one.r}`, \"g\"),\r\n\r\n//字符串重用\r\n    $ :string[] = [\r\n        \"鬼片出现了！\",\r\n        \"\",\r\n        \", automatically treated as one-way binding.\",\r\n        \"function\",\r\n        \"DO NOT USE \",\r\n        \" in Dynamic instance.\",\r\n        \" is a reserved property.\"\r\n    ];\r\n\r\n//主函数\r\nexport default function App(rootNode_ :Elementy, options_? :anyObject) :anyObject{\r\n\r\n//#region 常量声明\r\n    const \r\n    rootNode = utils.arguments.reduceToElement(rootNode_)!,\r\n    //数据属性\r\n    dataStore :dataObject = {},\r\n    //公开属性\r\n    publics :anyObject = {\r\n        rootNode,\r\n        hydrate,\r\n        addExport,\r\n        removeExport,\r\n        getExports,\r\n        connect,\r\n        disConnect,\r\n        getDataKeys,\r\n        //__getData__\r\n\r\n\r\n\r\n    },\r\n    reservedProperties = [\"length\", \"name\", \"prototype\", \"arguments\", \"caller\"],\r\n    //插值位置记录\r\n    insertStore = new WeakMap<Element | Text, string | null>(),\r\n    //代理函数\r\n    pfuncSymbol = Symbol(),\r\n    pfuncObj = {\r\n        [pfuncSymbol]: function(){\r\n            //seize:或许可以在这里运行什么？\r\n        }\r\n    };\r\n//#endregion\r\n\r\n//#region important:开发专用方法，构建前将publics中的引用删除即可\r\n    function __getData__(){\r\n        return dataStore;\r\n    }\r\n//#endregion\r\n\r\n//#region DOM监控系统 WeakMap：96.59%（2022.8.22）\r\n    const aOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    const dOProcessorStore = new WeakMap<Node, MRProcessorFn>();\r\n    const cOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    //简单的DOM监控回调机制，全看对面MRProcessorFn设计得如何\r\n    const observer :MutationObserver = new MutationObserver((records :MutationRecord[])=>{\r\n        for(let i = 0; i < records.length; i++){\r\n            const record = records[i], type = record.type;\r\n            //console.log(record);\r\n            //既然有attribute那肯定是Element\r\n            if(type == \"attributes\" && aOProcessorStore.has(record.target as Element)) aOProcessorStore.get(record.target as Element)!(record);\r\n            else if(type == \"characterData\" && dOProcessorStore.has(record.target)) dOProcessorStore.get(record.target)!(record);\r\n            //既然有childList那肯定是Element\r\n            else if(type == \"childList\" && cOProcessorStore.has(record.target as Element)) cOProcessorStore.get(record.target as Element)!(record);\r\n            //else\r\n        }\r\n    });\r\n//#endregion\r\n\r\n//#region 数据属性导出与更新CRUD\r\n    function addExport(){\r\n        //seize:\r\n    }\r\n    function removeExport(){\r\n        //seize:\r\n    }\r\n    function getExports(){\r\n        //seize:\r\n    }\r\n    function connect(){\r\n        //seize:\r\n    }\r\n    function disConnect(){\r\n        //seize:\r\n    }\r\n//#endregion\r\n\r\n//#region 数据属性杂项方法/处理\r\n    function getDataKeys() :string[]{\r\n        return Object.keys(dataStore);\r\n    }\r\n    //将公开属性挂载到代理函数上\r\n    for(let i in publics) (pfuncObj[pfuncSymbol] as anyObject)[i] = publics[i];\r\n//#endregion\r\n\r\n//#region 核心代理\r\n    //anyObject：指 鹿 为 马\r\n    const proxy :anyObject = new Proxy(pfuncObj[pfuncSymbol], {\r\n        get(target :anyObject, property :string, proxy :anyObject){\r\n            if(property in publics) return publics[property]; //提供保留属性\r\n            else if(property in dataStore){ //提供数据属性\r\n                //如果是“计算”属性就返回缓存值\r\n                if(typeof dataStore[property].value == $[3]) return dataStore[property].cache;\r\n                else return dataStore[property].value;\r\n            }\r\n            else return undefined; //不存在该属性\r\n        },\r\n        set(target :anyObject, property :string, newValue :any, proxy :anyObject){\r\n            if(property in publics) utils.generic.EE(`${property}${$[6]}`); //这里不会返回true而会报错\r\n            else if(property in dataStore){\r\n                //如果传入的是函数，那么就收集函数中需要的属性，将这些属性的shouldUpdate中推一个这个属性\r\n                //`a.shouldUpdate[number] = \"b\"` 的意思是：当属性a发生改变时，要去更新b\r\n                //更新b并不是运行一次b.value函数，而是去更新b.shouldExport，重新运行一遍这些方法，将DOM中的b更新\r\n                //我们也要同样地去b.shouldUpdate里将它们的shouldExport运行了，因为它们的值也“应该”改变了\r\n                //这是一个递归过程，一直从shouldUpdate下去，一直运行shouldExport\r\n                const oldValue = dataStore[property].value;\r\n                //给“计算”属性的更新开个后门\r\n                if(oldValue !== newValue || typeof newValue == $[3]){ //要是前后相同，那为什么还要更新呢？——嫖怪\r\n                    dataStore[property].value = newValue;\r\n                    processComputedProperty(dataStore[property]);\r\n                    //导出数据\r\n                    const exportInstances = dataStore[property].shouldExports;\r\n                    for(let i = 0; i < exportInstances.length; i++) exportInstances[i][0].call(proxy, exportInstances[i], oldValue);\r\n                    //更新需要更新的属性\r\n                    for(let i = 0; i < dataStore[property].shouldUpdates.length; i++) dfsUpdate(dataStore[property].shouldUpdates[i]);\r\n                    function dfsUpdate(prop :string) :void{\r\n                        if(prop in dataStore && typeof dataStore[prop].value == $[3]){ //找到计算属性\r\n                            const dfsOldValue = dataStore[prop].cache; //记录旧数据\r\n                            dataStore[prop].cache = dataStore[prop].value.call(proxy); //更新“计算”属性的缓存\r\n                            //导出数据\r\n                            const exportInstances = dataStore[prop].shouldExports;\r\n                            for(let i = 0; i < exportInstances.length; i++) exportInstances[i][0].call(proxy, exportInstances[i], dfsOldValue);\r\n                            //递归\r\n                            for(let i = 0; i < dataStore[prop].shouldUpdates.length; i++) dfsUpdate(dataStore[prop].shouldUpdates[i]);\r\n                        }\r\n                    }\r\n                }\r\n                //else console.log(`Update skipped in ${property} for same value ${newValue}`);\r\n            }\r\n            else{ //尚未有该属性，新建\r\n                dataStore[property] = lUtils.data.createData(newValue);\r\n                processComputedProperty(dataStore[property]);\r\n            }\r\n            return true;\r\n            /**建立cache，执行计算，分析函数，修改shouldUpdates，否则删除cache；并管理target附加显示*/\r\n            function processComputedProperty<T>(dataInstance :data<T>) :void{\r\n                if(typeof newValue == $[3]){\r\n                    lUtils.data.checkArrowFunction(newValue as Function);\r\n                    dataInstance.cache = (newValue as Function).call(proxy);\r\n                    const shouldUpdateThese = lUtils.data.detectShouldUpdate(Function.prototype.toString.call(newValue));\r\n                    //console.log(shouldUpdateThis, property);\r\n                    for(let i = 0; i < shouldUpdateThese.length; i++){\r\n                        //fixed:如果函数中访问了还没有创建的属性，那么我们也需要去创建它，因为shouldUpdateA不能在之后补上，并且在函数中提到了这个属性，那么创建它确实很合理。\r\n                        if(!(shouldUpdateThese[i] in dataStore)) proxy[shouldUpdateThese[i]] = undefined;\r\n                        if(dataStore[shouldUpdateThese[i]].shouldUpdates.indexOf(property) == -1) dataStore[shouldUpdateThese[i]].shouldUpdates.push(property);\r\n                    }\r\n                    //fixed:新建属性，让devTools能识别这个东西，下同\r\n                    if(reservedProperties.indexOf(property) == -1) target[property] = dataInstance.cache;\r\n                }\r\n                else{ //将“计算”属性变成普通属性\r\n                    delete dataInstance.cache; //反正delete不报错，随便操作\r\n                    if(reservedProperties.indexOf(property) == -1) target[property] = dataInstance.value;\r\n                }\r\n            }\r\n        },\r\n        deleteProperty(target :anyObject, property :string){\r\n            const exists = property in dataStore;\r\n            if(property in publics) utils.generic.EE(`${property}${$[6]}`);\r\n            else if(exists){\r\n                delete dataStore[property];\r\n                delete target[property];\r\n            }\r\n            return exists;\r\n        },\r\n        apply(target, thisArg :any, argArray :any[]){\r\n            //todo:用于更新属性\r\n            if(argArray.length == 1 && argArray[0] in dataStore && \"cache\" in dataStore[argArray[0]]){\r\n                proxy[argArray[0]] = dataStore[argArray[0]].value;\r\n            }\r\n            else if(argArray.length == 0){\r\n                console.log(\"todo: update all computed data properties\");\r\n            }\r\n        },\r\n        construct(target, argArray :any[], newTarget){\r\n            //seize:暂时不知道能用来干嘛\r\n            return {version};\r\n        },\r\n        //getPrototypeOf(target){}, 无需拦截\r\n        has(_target, property :string){return Reflect.has(dataStore, property);},\r\n        getOwnPropertyDescriptor(target, property :string){\r\n            if(property in dataStore) return Reflect.getOwnPropertyDescriptor(dataStore, property);\r\n            else return Reflect.getOwnPropertyDescriptor(target, property);\r\n        },\r\n        ownKeys(_target){return utils.generic.noRepeat([...Reflect.ownKeys(dataStore), \"prototype\", \"caller\", \"arguments\", \"length\", \"name\"]) as string[];},\r\n        isExtensible(){return true;},\r\n        defineProperty(){utils.generic.EE(`${$[4]}defineProperty${$[5]}`);return false;},\r\n        preventExtensions(){utils.generic.EE(`${$[4]}preventExtensions${$[5]}`);return false;},\r\n        setPrototypeOf(){utils.generic.EE(`${$[4]}setPrototypeOf${$[5]}`);return false;}\r\n    });\r\n//#endregion\r\n\r\n//#region HTML模板转换\r\n    //fixme:不转换已经是模板的内容，通过插值记录\r\n    function hydrate(node :Node) :void{\r\n        if(node instanceof Element){\r\n            //超级hack完美解决作用域内部元素on*事件必须访问全局App才能访问数据的问题\r\n            //给作用域内每个元素的_都弄上proxy，然后只要this一下就出来了！\r\n            //todo:真正地将on*事件转为内部事件，需要\r\n            //lUtils.misc.noErrorDefineProperties(node, {\r\n            //    _: {\r\n            //        configurable: false,\r\n            //        enumerable: true,\r\n            //        get(){return proxy;}\r\n            //    }\r\n            //});\r\n            const attrs = Array.from(node.attributes), children = Array.from(node.childNodes) as Node[];\r\n            //记录必要信息，在遍历完所有属性后再执行破坏性操作，保证这个for循环是纯函数\r\n            const tasks :[1 | 2, string, string, string][] = [];\r\n            for(let i = 0; i < attrs.length; i++){\r\n                //#region 关于attribute与property的讨论\r\n                /*important:fixed:对于某些attribute来说，它们本身只是一个默认值，想要获得真正的值需要访问节点的对应property！\r\n                但是我们无法知道哪些attribute有这种阴间问题，到时候一味更新attribute没更新到property就没用了\r\n                目前看了看标准和文档，来试图真正说清楚这个。\r\n                我们将property/attribute组合叫pa组合，将 $0[property] = x会导致$0.getAttribute(\"property\") === x 称为 拥有完整的p->a同步，将 $0.setAttribute(\"property\", x)会导致$0[property] === x 称为 拥有完整的a->p同步，将拥有完整的p->a同步和拥有完整的a->p同步称为完全双向同步，拥有两者中任一种称为单向同步。\r\n                如果存在同步，但property的值需要改变，那么称为非同名同步。\r\n                pa组合一共有以下几种：1. 同名且完全双向同步，如accept。2. 不同名且完全双向同步，如value(a)和defaultValue(p)。3. 不同名且不可能双向同步，因为两边的格式不同，如style。但是这种情况下浏览器已经做好了转换，可以近似视作第二种。\r\n                由此可见pa组合一定存在双向同步，这和whatwg.org的标准是完全相符的；但是可能名字不同。这个名字不同问题很大，因为有的只是kebab转camel，有的整个都变了，如value->defaultValue，class->className。\r\n                并且有的不同组合的a和p存在一次性的同步，这个“一次性”发生在第一次加载页面（Gecko和IE）或每次刷新页面（chromium）\r\n                例如value(a)和value(p)，它们不是一个组合（value(a)和defaultValue(p)才是一对的），一次性同步方向为value(a)->value(p)。\r\n                我们的目的是：能够做到属性值与data双向同步，即修改属性值会触发data修改且触发data should*事件，修改data触发属性值的修改。\r\n                然而property不能被监控，只有attribute可以用observer监控，所以我们只能用常规方法做到存在与之对应的attribute的property的响应式\r\n                像<input>中的value和checked这两个property，没有对应的attribute，于是我们必须用另一种方法：直接设置property。\r\n                我们也不能通过observer实现双向绑定，但还好浏览器提供了oninput事件，可以用这个补回去。\r\n                于是可以做了！\r\n                参考链接：\r\n                https://javascript.info/dom-attributes-and-properties#:~:text=But%20there%20are%20exclusions\r\n                https://stackoverflow.com/questions/57475325\r\n                https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes\r\n                */\r\n                //#endregion\r\n                \r\n                let name = attrs[i].name, value = attrs[i].value; //???:这里不能用var？不同次for之间居然能共享var变量？\r\n                const nameOne = !!name.match(oneRegExp),\r\n                      nameTwo = !!name.match(twoRegExp),\r\n                      valueOne = !!value.match(oneRegExp),\r\n                      valueTwo = !!value.match(twoRegExp),\r\n                      nameInserted = nameOne || nameTwo,\r\n                      valueInserted = valueOne || valueTwo;\r\n                let name_property :string,\r\n                    value_property :string,\r\n                    //这两个和name一起构成了一个筛查链条：如果有${DSL.attrAdditional}，那么%2和%1不同，如果有default陷阱那么%3也和%2不同\r\n                    //最终%3是真正在设置的东西\r\n                    processed_avoidance_name :string,\r\n                    processed_avoidance_defaultTrap_name :string;\r\n                \r\n                //各种警告\r\n                if(nameTwo) console.warn(`It's not rational to declare a two-way binding attribute name: ${name}${$[2]} Use \"${DSL.one.l}${name.substring(2, name.length - 2)}${DSL.one.r}\" instead.`);\r\n                //这个还是不能允许\r\n                if(nameInserted && valueInserted) console.warn(\"Cannot set an attribute with both name and value dynamic. Dynamic will make only attribute name dynamic.\");\r\n                \r\n                //属性名和属性值都要求全部是插值，不允许中途插值；其中属性值支持双向绑定\r\n                if(nameInserted){ //处理属性名\r\n                    name_property = name.substring(2, name.length - 2);\r\n                    //更新attribute的名称，值不改变；但是本质上是删除旧attribute，添加新attribute；因此必须需要一个参数，否则无从得知是哪个attribute\r\n                    const symbol = Symbol();\r\n                    const funcObj = {\r\n                        [symbol]: function(this :anyObject, exportInstance :exportInstance, oldValue :string){ //参数里放this不影响函数的参数\r\n                            const newValue = this[name_property];\r\n                            //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                            if(oldValue !== newValue){\r\n                                const thisNode = exportInstance[1] as Element,\r\n                                valueOfAttr = thisNode.getAttribute(oldValue)!;\r\n                                //要先删除，因为setAttribute可能会出错，出错了就会多一个attribute\r\n                                //出错后再次设置数据属性的值时，如果成功设置了attr，attr值也会是null，因为上次没有成功，旧的attr值直接没了，这完全符合预期！\r\n                                thisNode.removeAttribute(oldValue);\r\n                                if(newValue !== \"\"){\r\n                                    //警告开（我）发（自）者（己）不要传大写字母进属性名\r\n                                    if(typeof newValue == \"string\" && newValue !== newValue.toLowerCase()) console.warn(`Attribute names are case insensitive, don't pass string with upper-case letters which may cause bugs: ${newValue}`);\r\n                                    thisNode.setAttribute(newValue, valueOfAttr);\r\n                                }\r\n                                //else \"\"不是有效的属性名称，所以我们将它视为属性被动态删除了\r\n                            }\r\n                            //else return; //值没有改变，直接返回\r\n                        }\r\n                    };\r\n                    if(!(name_property in proxy)) proxy[name_property] = undefined; //创建属性\r\n                    lUtils.data.addExport(proxy, dataStore[name_property], funcObj[symbol], node); //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                }\r\n                else if(valueInserted){ //处理属性值\r\n                    value_property = value.substring(2, value.length - 2);\r\n                    //筛查规避属性\r\n                    if(name[name.length - 1] == DSL.attr) processed_avoidance_name = name.substring(0, name.length - 1);\r\n                    else processed_avoidance_name = name;\r\n                    let funcObj :functionObject = {};\r\n                    if( //特殊attribute/property处理\r\n                        (processed_avoidance_name == \"value\" || processed_avoidance_name == \"checked\")\r\n                     && node instanceof HTMLInputElement //避免其他元素上可能存在这些开发者自定义的属性，造成干扰\r\n                     && processed_avoidance_name in node //这个东西感觉没啥作用，其实只是加个保险。检测是否存在对应property，似乎value真的在input的原型链上而不是它本身的属性\r\n                    ) funcObj.func = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                        const newValue = this[value_property];\r\n                        //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                        if(oldValue !== newValue) (node as anyObject)[processed_avoidance_name] = newValue;\r\n                    }\r\n                    else{\r\n                        //处理上一个if过滤掉的对称情况\r\n                        if(node instanceof HTMLInputElement){\r\n                            //快死了，乱转大写小写的\r\n                            if(processed_avoidance_name == \"defaultvalue\" && \"defaultValue\" in node) processed_avoidance_defaultTrap_name = \"value\";\r\n                            else if(processed_avoidance_name == \"defaultchecked\" && \"defaultChecked\" in node) processed_avoidance_defaultTrap_name = \"checked\";\r\n                            else processed_avoidance_defaultTrap_name = processed_avoidance_name;\r\n                        }\r\n                        else processed_avoidance_defaultTrap_name = processed_avoidance_name;\r\n                        funcObj.func = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                            const newValue = this[value_property];\r\n                            //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                            if(oldValue !== newValue){\r\n                                //我们将null视为属性被动态删除了\r\n                                if(newValue === null) node.removeAttribute(processed_avoidance_defaultTrap_name); //setAttribute删不掉\r\n                                else node.setAttribute(processed_avoidance_defaultTrap_name, newValue);\r\n                            } \r\n                            //else 值没有改变，直接返回\r\n                        }\r\n                    }\r\n                    if(!(value_property in proxy)) proxy[value_property] = undefined; //创建属性\r\n                    lUtils.data.addExport(proxy, dataStore[value_property], funcObj.func, node); //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                    //#region 双向绑定补丁\r\n                    if(valueTwo){\r\n                        //特别处理这几个东西，就是这里需要用到原始的name\r\n                        if(node instanceof HTMLInputElement){\r\n                            if(name == \"value\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) proxy[value_property] = node.value;\r\n                                });\r\n                            }\r\n                            else if(name == \"checked\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) proxy[value_property] = node.checked;\r\n                                });\r\n                            }\r\n                            //else if(name == \"defaultValue\") 不需要了，跟着下面去监听就行了\r\n                        }\r\n                        else{\r\n                            aOProcessorStore.set(node, (record: MutationRecord)=>{\r\n                                //使用record.target而不是node，否则会增加内存占用\r\n                                if(\r\n                                    record.attributeName === processed_avoidance_defaultTrap_name\r\n                                //只有在attribute值和数据属性的值不一样的时候才需要同步，否则会导致无限同步\r\n                                 && (record.target as Element).getAttribute(record.attributeName!) !== proxy[value_property]\r\n                                ) proxy[value_property] = (record.target as Element).getAttribute(record.attributeName!);\r\n                            });\r\n                        }\r\n                    }\r\n                    //#endregion\r\n                }\r\n                //else\r\n\r\n                //录入破坏性任务\r\n                if(nameInserted) tasks.push([1, name, name_property!, value]);\r\n                else if(valueInserted) tasks.push([2, name, processed_avoidance_defaultTrap_name!, value_property!]);\r\n            }\r\n\r\n            //执行破坏性任务\r\n            for(let i = 0; i < tasks.length; i++){\r\n                const taskInstance = tasks[i];\r\n                if(taskInstance[0] == 1){ //属性名匹配\r\n                    node.removeAttribute(taskInstance[1]); //删除旧属性\r\n                    //这个不能用__addedByDynamic__代替，因为它出于性能原因会检查属性值是否没有改变\r\n                    node.setAttribute(proxy[taskInstance[2]], taskInstance[3]); //将value搬迁到新的attribute中\r\n                }\r\n                else if(taskInstance[0] == 2){ //属性值匹配\r\n                    //是特殊attribute/property，不应setAttr而应修改property\r\n                    if(taskInstance[2] === undefined) (node as anyObject)[taskInstance[1]] = proxy[taskInstance[3]];\r\n                    //这个不能用__addedByDynamic__代替，因为它出于性能原因会检查属性值是否没有改变\r\n                    else{\r\n                        node.removeAttribute(taskInstance[1]); //使用最初的name来删除旧属性\r\n                        node.setAttribute(taskInstance[2], proxy[taskInstance[3]]); //将数据属性的值export一次\r\n                    }\r\n                }\r\n                //else\r\n            }\r\n\r\n            //进入子节点\r\n            for(let i = 0; i < children.length; i++) hydrate(children[i]);\r\n        }\r\n        else if(node instanceof Text){ //fixed:如果修改Element的textContent则会覆盖所有子元素，所以我们仅在文本节点上执行这边的代码\r\n            if(utils.element.processNLIText(node) !== null && node.textContent){\r\n                //双向绑定直接视为单向绑定并警告\r\n                const text = node.textContent, twoWayInserts = [...text.matchAll(multiTwoRegExp)],\r\n                      totalInserts = [...text.matchAll(multiOneRegExp), ...twoWayInserts],\r\n                      matchtwo = !!text.match(twoRegExp),\r\n                      matchone = !!text.match(oneRegExp);\r\n                if(twoWayInserts.length > 0 && !matchtwo) console.warn(`Two-way bindings in \"${text}\" cannot be used in textContent template${$[2]}`);\r\n\r\n                //这里是单插值双向绑定，只有单向绑定支持模板，双向绑定是不支持的，意思就是必须全都是并且是整个元素全都是，不允许出现其他兄弟节点\r\n                //这种情况需要先判断，因为后一种情况包含了这一种情况\r\n                if(matchtwo){\r\n                    //fuck:我要爆粗口了！TS没十年脑溢血写不出来啊！你™parentElement返回类型HTMLElement？？？\r\n                    //有生之年我居然在判断HTMLElement instanceof HTMLElement！\r\n                    //并且ts还号称要平衡生产力和准确性，不修这个问题！2015年的老issue了https://github.com/microsoft/TypeScript/issues/4689#issuecomment-146324456\r\n                    if(!(node.parentElement! instanceof HTMLElement)) console.warn(\"It's no use adding a two-way binding to an SVGElement but dynamic will continue.\");\r\n                    const property = text.substring(2, text.length - 2),\r\n                          parent = node.parentNode!; //不可能没有parentNode！\r\n                    if(parent.childNodes.length == 1){\r\n                        const symbol = Symbol();\r\n                        const funcObj = {\r\n                            [symbol]: function(this :anyObject){\r\n                                //fixed:由于目前parent里只有一个只有一个插值Element，我们完全可以直接将内容写进parent；\r\n                                //fixme:双向绑定未实装。\r\n                                //const data = this[property];\r\n                                //if(parent.textContent !== data){\r\n                                //    if(data instanceof Element || (data instanceof Array && data[0] instanceof Element)){\r\n                                //        //review:做的比较匆忙\r\n                                //        //todo:这里必须过滤数据未改动的情况，使用vDOM（未实装），否则相当于不用框架\r\n                                //        (parent as Element).innerHTML = \"\";\r\n                                //        if(data instanceof Element) parent.appendChild(data);\r\n                                //        else for(let i = 0; i < data.length; i++){\r\n                                //            if(data[i] instanceof Element) parent.appendChild(data[i]);\r\n                                //            else parent.appendChild(document.createTextNode(lUtils.misc.advancedStringify(data[i])));\r\n                                //        }\r\n                                //        return;\r\n                                //    }\r\n                                //    else parent.textContent = data;\r\n                                //}\r\n                                ///*let t = text;\r\n                                //if(!document.contains(exportInstance[1]!)){ //检查旧文本节点还在不在，这个别过滤，常回家看看他不香吗？\r\n                                //    let oldNode = exportInstance[1]!;\r\n                                //    exportInstance[1] = document.createTextNode(t); //text是模板字符串，要用text才能replaceAll\r\n                                //    parent.appendChild(exportInstance[1]); //随便，反正就一个节点\r\n                                //}\r\n                                //let thisNode = exportInstance[1]!, data = this[property];\r\n                                ////过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                                //if(data !== oldValue){\r\n                                //    //fixed:见initData()->Proxy->set\r\n                                //    if(typeof data == \"object\") data = lUtils.misc.advancedStringify(data);\r\n                                //    //todo:输出HTML DOM\r\n                                //    t = t.replaceAll(`${DSL.twoWayBinding.l}${property}${DSL.twoWayBinding.r}`, data);\r\n                                //    //上面不能做到完全过滤，所以这里来个终极过滤\r\n                                //    if(thisNode.textContent !== t) thisNode.textContent = t; //不修改innerText而是修改textContent，因为innerText会每次都触发浏览器绘制过程\r\n                                //}*/\r\n                            }\r\n                        };\r\n                        if(!(property in proxy)) proxy[property] = undefined; //创建属性\r\n                        lUtils.data.addExport(proxy, dataStore[property], funcObj[symbol], node);\r\n                        //fixed:note:已经验证：chromium会乱搞文本节点，具体内容是：\r\n                        //仅在chromium中：两个文本节点在一起，在开发者工具中编辑前面那个后后面那个的内容会加到前面，后面那个被删，编辑后面那个会将前面那个删掉。\r\n                        //设置textContent = \"\"，文本节点不会被删。\r\n                        //contenteditable后内容被用户清空，文本节点不会被删。仅在chromium中：再输入内容时重建的是另一个文本节点，即使设置了webkit-user-modify: read-write-plaintext-only。\r\n                        //因此会出现contenteditable内容清空后新内容输入到新节点的情况\r\n                        //succeed:有解决方案了！可以通过input事件从父元素获取数据！不用抓着文本节点不放了！\r\n                        parent.addEventListener(\"input\", (e :Event)=>{\r\n                            if(e.target === parent && parent.textContent !== proxy[property]) proxy[property] = parent.textContent;\r\n                            //todo:目前只支持文本，要支持HTML DOM双向绑定可能需要重构上面的代码\r\n                        });\r\n                        //这边需要自己上阵干掉标识\r\n                        node.textContent = proxy[property];\r\n                    }\r\n                    else console.error(\"The parent element of a two-way binding text node must only have this text node.\");\r\n                }\r\n                //没有匹配到则为null，匹配到则[n]为${DSL.one.l}example${DSL.one.r}\r\n                else if(totalInserts.length > 0){\r\n                    const parent = node.parentNode!, nextNode = node.nextSibling, //不可能没有parentNode！https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentNode#%E5%A4%87%E6%B3%A8\r\n                    //构造并记录export方法\r\n                    properties = (()=>{ //收集数据并创建尚未创建的属性\r\n                        const result = [];\r\n                        for(let i = 0; i < totalInserts.length; i++){\r\n                            const property = totalInserts[i][0].substring(2, totalInserts[i][0].length - 2);\r\n                            result.push(property);\r\n                            if(!(property in dataStore)) proxy[property] = undefined;\r\n                        }\r\n                        return utils.generic.noRepeat(result);\r\n                    })(), symbol = Symbol();\r\n                    //这里是单/双向绑定，如果只有一个插值那么允许使用HTML DOM不允许字符串模板，否则反过来\r\n                    if(totalInserts.length = 1){\r\n                        const onlyProperty = properties[1];\r\n                        //允许HTML DOM不允许字符串模板\r\n                        const funcObj = {\r\n                            [symbol]: function(this :anyObject, exportInstance :exportInstance){\r\n                                //review:做的比较匆忙\r\n                                //todo:fixme:important:这里没能做完，现在dynamic不能正常运行\r\n                                //let template = text; //为了保证它是值类型，node.textContent是引用类型，会变\r\n                                let data = this[onlyProperty];\r\n                                //if(typeof data == \"object\"){\r\n                                //    if(\r\n                                //        (data instanceof Element\r\n                                //     || (data instanceof Array && data[0] instanceof Element))\r\n                                //    ){\r\n                                //        exportInstance[2] = true;\r\n                                //        \r\n                                //        //todo:这里必须过滤数据未改动的情况，使用vDOM（未实装），否则相当于不用框架\r\n                                //        (parent as Element).innerHTML = \"\";\r\n                                //        if(data instanceof Element) parent.appendChild(data);\r\n                                //        else for(let i = 0; i < data.length; i++){\r\n                                //            if(data[i] instanceof Element) parent.appendChild(data[i]);\r\n                                //            else parent.appendChild(document.createTextNode(lUtils.misc.advancedStringify(data[i])));\r\n                                //        }\r\n                                //    }\r\n                                //    else data = lUtils.misc.advancedStringify(data);\r\n                                //}\r\n                                (parent as HTMLElement).innerHTML = data;\r\n                            }\r\n                        };\r\n                        for(let i = 0; i < properties.length; i++) lUtils.data.addExport(proxy, dataStore[properties[i]], funcObj[symbol], node);\r\n                    }\r\n                    else{\r\n                        //不允许HTML DOM，允许文本模板\r\n                        //我们先确定这一段文字中所有需要的属性，然后保存好这一段文字，然后给这些属性添加export方法\r\n                        //方法的具体内容是收集所有需要的属性，用保存好的文字作模板进行逐个属性的替换，最后塞回节点里\r\n                        const funcObj = {\r\n                            [symbol]: function(this :anyObject, exportInstance :exportInstance){ //参数里放this不影响函数的参数\r\n                                let template = text; //为了保证它是值类型，node.textContent是引用类型，会变\r\n                                if(!document.contains(exportInstance[1]!)){ //检查旧文本节点还在不在\r\n                                    exportInstance[1] = document.createTextNode(template); //要用template才能replaceAll\r\n                                    parent.insertBefore(exportInstance[1], nextNode);\r\n                                }\r\n                                let thisNode = exportInstance[1]!;\r\n                                //exportInstance[2] = false; //???:这个到底是用来干什么的？\r\n                                //由于不知道调用该函数的数据属性（caller）是哪个，无法过滤数据并未改动的情况，也因此会收到addExport的初始调用\r\n                                for(let i = 0; i < properties.length; i++){\r\n                                    let data = this[properties[i]];\r\n                                    if(typeof data == \"object\") data = lUtils.misc.advancedStringify(data);\r\n                                    template = template //这里也需要处理双向绑定，因为多插值模板中的双向绑定被当作是单向绑定了\r\n                                    .replaceAll(`${DSL.one.l}${properties[i]}${DSL.one.r}`, data)\r\n                                    .replaceAll(`${DSL.two.l}${properties[i]}${DSL.two.r}`, data);\r\n                                }\r\n                                if(thisNode.textContent !== template) thisNode.textContent = template;\r\n                            }\r\n                        };\r\n                        for(let i = 0; i < properties.length; i++) lUtils.data.addExport(proxy, dataStore[properties[i]], funcObj[symbol], node);\r\n                    }\r\n                }\r\n                else{ //其他情况不用判断\r\n                    //测试B\r\n                    console.log(node, text, twoWayInserts, totalInserts, matchone, matchtwo);\r\n                }\r\n            }\r\n            else node.remove(); //否则直接删除空节点，节点可能已被processNLIText删除，不过我们再来一次也没事\r\n        }\r\n        //else console.error($[0], node); //这里没有鬼片，注释节点会走到这里\r\n    }\r\n//#endregion\r\n\r\n//#region 启动实例\r\n    console.info(\"creating new dynamic instance with rootNode\", rootNode);\r\n    hydrate(rootNode);\r\n    observer.observe(rootNode, { //在hydrate后执行，不用观察自己对DOM的修改\r\n        attributes: true,\r\n        attributeOldValue: true,\r\n        characterData: true,\r\n        characterDataOldValue: true,\r\n        childList: true,\r\n        subtree: true\r\n    });\r\n    return proxy;\r\n//#endregion\r\n\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n/*export default class Template{\r\n    \r\n}*/\r\nexport function register(){\r\n\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function getSearch() :SSkvObject | null{\r\n    var s = location.search;\r\n    if(s != \"\"){\r\n        s = s.substring(1);\r\n        const result :SSkvObject = {};\r\n        s.split(\"&\").forEach(value=>{\r\n            const sp = value.split(\"=\");\r\n            result[sp[0]] = sp[1];\r\n        });\r\n        return result;\r\n    }\r\n    else return null;\r\n}\r\nexport function getHash() :string{\r\n    return location.hash.substring(1);\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function add(){\r\n    //todo:\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n\r\n//分文件开发\r\nimport App from \"./app\";\r\nimport * as template from \"./template\";\r\nimport * as spa from \"./spa\";\r\nimport * as manifest from \"./manifest\";\r\n\r\n//构造导出对象\r\nconst Dynamic$ = App as Dynamic;\r\n    //引入模块\r\nDynamic$.template = template;\r\nDynamic$.spa = spa;\r\nDynamic$.manifest = manifest;\r\n    //工具方法\r\nDynamic$.e = utils.element.e;\r\nDynamic$.render = (args :{\r\n    HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[];\r\n    element :Element, insertAfter? :boolean, append? :boolean\r\n}) :Node[]=>{return utils.element.render(args.HTML, args.element, args.insertAfter, args.append);};\r\nDynamic$.toHTML = utils.element.toHTML;\r\nDynamic$.hatch = utils.element.hatch;\r\nDynamic$.compose = ()=>{}; //todo:\r\n\r\n//导出\r\nconst Dynamic :Dynamic = Dynamic$;\r\nutils.generic.constantize(Dynamic);\r\nexport default Dynamic;","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\n/**一定会返回Element，void为报错hack*/\r\nexport function reduceToElement(input :Elementy) :Element | void{\r\n    if(input instanceof Element) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el as Element;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\");\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}\r\n/**一定会返回Node，void为报错hack*/\r\nexport function reduceToNode(input :Nody) :Node | void{\r\n    if(input instanceof Node) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\");\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport Dynamic$ from \"./dynamic.export\";\r\n//fixed:当作模块使用的时候不需要弄到全局作用域，所以将这个东西抽出来了\r\nObject.defineProperty(window, \"Dynamic\", {\r\n    configurable: false,\r\n    writable: false,\r\n    enumerable: true,\r\n    value: Dynamic$\r\n});"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","E","argument","type","reason","undefined","Error","console","error","EE","message","noRepeat","input","Array","from","Set","e","s","scope","Element","document","a","querySelectorAll","length","match","toHTML","HTML","ele","createElement","innerHTML","el","nodes","i","childNodes","cloneNode","getInnerNodesClone","clearInterval","FtoString","Function","toString","proxy","dataInstance","func","target","sE","shouldExports","checkArrowFunction","isDuplicated","warn","exportInstance","push","advancedStringify","result","properties","keys","toStringed","compatibleToString","input_","object","objects","WeakMap","checkCycle","path","Boolean","Date","Number","RegExp","String","prev_path","indexOf","$ref","set","newObj","JSON","stringify","addResult","input2","version","DSL","l","r","twoRegExp","oneRegExp","multiTwoRegExp","multiOneRegExp","$","register","getSearch","location","search","substring","split","forEach","sp","getHash","hash","add","Dynamic$","rootNode_","options_","rootNode","Node","dataStore","publics","hydrate","addExport","removeExport","getExports","connect","disConnect","getDataKeys","reservedProperties","pfuncSymbol","pfuncObj","aOProcessorStore","dOProcessorStore","cOProcessorStore","observer","MutationObserver","records","record","has","Proxy","property","cache","newValue","oldValue","processComputedProperty","exportInstances","shouldUpdates","dfsUpdate","dfsOldValue","shouldUpdate","shouldExport","shouldUpdateThese","string","inQuote","double","single","reversed","subCursor","deleteProperty","exists","apply","thisArg","argArray","construct","newTarget","_target","Reflect","getOwnPropertyDescriptor","ownKeys","isExtensible","preventExtensions","setPrototypeOf","node","attrs","attributes","children","tasks","name","nameOne","nameTwo","valueOne","valueTwo","nameInserted","valueInserted","name_property","value_property","processed_avoidance_name","processed_avoidance_defaultTrap_name","symbol","funcObj","this","thisNode","valueOfAttr","getAttribute","removeAttribute","toLowerCase","setAttribute","HTMLInputElement","addEventListener","checked","attributeName","taskInstance","Text","textNode","textContent","signContent","replace","parent","parentElement","des","designMode","tagName","HTMLElement","isContentEditable","remove","text","twoWayInserts","matchAll","totalInserts","matchtwo","parentNode","nextNode","nextSibling","onlyProperty","data","template","contains","createTextNode","insertBefore","replaceAll","observe","attributeOldValue","characterData","characterDataOldValue","childList","subtree","spa","manifest","render","args","element","insertAfter","append","html","HTMLCollection","NodeList","item","Rhtml","reverse","prepend","hatch","par","compose","Dynamic","constantize","freeze","window","configurable","writable"],"sourceRoot":""}