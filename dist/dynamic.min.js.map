{"version":3,"file":"dynamic.min.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///../utils/generic.ts","webpack:///../utils/element.ts","webpack:///./src/utils/data.ts","webpack:///./src/utils/misc.ts","webpack:///./src/libs/cycle.ts","webpack:///./src/app.ts","webpack:///../utils/arguments.ts","webpack:///./src/template.ts","webpack:///./src/spa.ts","webpack:///./src/manifest.ts","webpack:///./src/dynamic.export.ts","webpack:///./src/dynamic.defineGlobal.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function randoma2Z(length :number) :string{ //52\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 52);\r\n        if(r > 25) s += String.fromCharCode(r + 71);\r\n        else s += String.fromCharCode(r + 65);\r\n    }\r\n    return s;\r\n}\r\nexport function randoma2z029(length :number) :string{ //36\r\n    var s :string = \"\";\r\n    for(let i = 0; i < length; i++){\r\n        let r = Math.floor(Math.random() * 36);\r\n        if(r < 10) s += r;\r\n        else s += String.fromCharCode(r + 87);\r\n    }\r\n    return s;\r\n}\r\nexport function precisePop<T>(ele :T, array :any[]) :T | null{\r\n    if(array.indexOf(ele) === -1) return null;\r\n    return array.splice(array.indexOf(ele), 1)[0];\r\n}\r\n//递归冻结对象\r\nexport function constantize(obj :anyObject) :void{\r\n    Object.freeze(obj);\r\n    for(let i = 0; i < Object.keys(obj).length; i++) if(typeof obj[Object.keys(obj)[i]] == \"object\") constantize(obj[Object.keys(obj)[i]]);\r\n}\r\nexport function E(argument :string, type? :string, value? :any, reason? :string) :never{\r\n    if(argument === undefined) throw new Error(\"An error occured.\");\r\n    else{\r\n        console.error(\"ERROR INFO: argument\", argument, \",type\", type, \",value\", value, \",reason\", reason); //为了拿到真正的value，其他类型toString后啥信息都没了\r\n        throw new Error(`Argument '${argument}' ${type ? `should be a(an) ${type}` : \"is invalid\"}${reason ? `, reason: ${reason}` : \"\"}${value ? `, got ${value}` : \"\"}.`);\r\n    }\r\n}\r\nexport function EE(message :any) :never{throw new Error(message);}\r\nexport function repeat<T>(item :T, count :number) :T[]{\r\n    if(typeof count != \"number\" || count < 1) utils.generic.E(\"count\", \"integer bigger than 0\", count);\r\n    return Array(count).fill(item, 0, count);\r\n}\r\nexport function noRepeat<T>(input :T[]) :T[]{\r\n    return Array.from(new Set(input)); //Set可是连IE11都支持的东西啊\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\nexport function e(s :string, scope? :Element | Document) :Node[] | Node{\r\n    if(scope === undefined || !(scope instanceof Element)) scope = document;\r\n        let a :NodeList = scope.querySelectorAll(s);\r\n        if(!a.length) return [];\r\n        //note:当一个页面存在相同ID元素时不会走这里，而会返回数组，因为说好了是querySelectorAll了并且本来就不应该有重复ID，不能怪我啊\r\n        if(a.length == 1 && s.match(/^.*#[^\\s]*$/)) return a[0];\r\n        else return Array.from(a);\r\n}\r\n/**@deprecated use `Node.contains` instead.*/\r\nexport function isDescendant(possibleDescendant :Node, possibleParent :Node) :boolean{\r\n    return possibleParent.contains(possibleDescendant);\r\n    /*while(\r\n        possibleDescendant instanceof Text\r\n     || (possibleDescendant instanceof Element && possibleDescendant.tagName != \"HTML\")\r\n    ){\r\n        possibleDescendant = possibleDescendant.parentNode! as Element;\r\n        if(possibleDescendant === possibleParent) return true; \r\n    }\r\n    return false;*/\r\n}\r\nexport function isInDocument(node :Node) :boolean{\r\n    return ((e(\"html\") as Node[])[0]).contains(node);\r\n    //return isDescendant(element, (e(\"html\") as Node[])[0] as Element);\r\n}\r\nexport function isChild(node :Node, target :Element) :boolean{\r\n    return Array.from(target.childNodes).indexOf(node as ChildNode) != -1;\r\n    /*const children = target.childNodes;\r\n    for(let i = 0; i < children.length; i++) if(element === children[i]) return true;\r\n    return false;*/\r\n}\r\nexport function toHTML(HTML :string) :Node[]{\r\n    if(HTML === \"\" || typeof HTML != \"string\") utils.generic.E(\"HTML\", \"string\", HTML);\r\n    const ele = document.createElement(\"div\");\r\n    ele.innerHTML = HTML;\r\n    return getInnerNodesClone(ele);\r\n}\r\nexport function getInnerNodesClone(el :Node) :Node[]{\r\n    var nodes :Node[] = [];\r\n    for(let i = 0; i < el.childNodes.length; i++) nodes[i] = el.childNodes[i].cloneNode(true);\r\n    return nodes;\r\n}\r\n//剥壳器\r\nexport function hatch(element :Element, remove? :boolean) :Node[]{\r\n    //note:Nodelist类型会实时同步造成不稳定的for循环，必须转换为Node[]！\r\n    const par = element.parentElement!, children :Node[] = Array.from(element.childNodes);\r\n    for(let i = 0; i < children.length; i++) par.insertBefore(children[i], element);\r\n    if(remove === true) element.remove();\r\n    return children;\r\n}\r\n//fixme:这个方法特异性太强了吧，能不能不要放在这里？\r\n//最终渲染方法，老祖宗求你别出bug\r\nexport function render(\r\n    HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[],\r\n    element :Element,\r\n    insertAfter? :boolean,\r\n    append? :boolean\r\n) :Node[]{\r\n    if(element.parentElement === null) utils.generic.EE(\"cannot render by '<html>' element, since it's root of document.\");\r\n    var html :Node[] = [];\r\n    if(typeof HTML == \"string\") html = toHTML(HTML);\r\n    else if(HTML instanceof Element || HTML instanceof Node) html[0] = HTML.cloneNode(true);\r\n    else if(HTML instanceof HTMLCollection || HTML instanceof NodeList) for(let i = 0; i < HTML.length; i++) html[i] = HTML.item(i)!.cloneNode(true);\r\n    else html = HTML;\r\n    const Rhtml = [...html].reverse(), parent = element.parentElement;\r\n    if(append === true) for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    else if(append === false) for(let i = 0; i < Rhtml.length; i++) element.prepend(Rhtml[i]);\r\n    else if(insertAfter === true){\r\n        if(!element.nextSibling) for(let i = 0; i < Rhtml.length; i++) parent!.append(Rhtml[i]);\r\n        else for(let i = 0; i < Rhtml.length; i++) parent!.insertBefore(Rhtml[i], element.nextSibling);\r\n    }\r\n    else if(insertAfter === false) for(let i = 0; i < html.length; i++) parent!.insertBefore(html[i], element);\r\n    else for(let i = 0; i < html.length; i++) element.append(html[i]);\r\n    //todo:加入作用域\r\n    return html;\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nconst FtoString = Function.prototype.toString;\r\n/**这里只负责创建对象并赋值，不负责任何值处理！*/\r\nexport function createData<T>(\r\n    value? :T,\r\n    shouldUpdate? :shouldUpdateA,\r\n    shouldExport? :shouldExportA\r\n) :data<T>{\r\n    const result :data<T> = {\r\n        value,\r\n        deleted: false,\r\n        shouldUpdates: shouldUpdate || [],\r\n        shouldExports: shouldExport || []\r\n    }\r\n    if(typeof result.value == \"function\") result.cache = undefined;\r\n    return result;\r\n}\r\n/**这里如果添加成功会自动引发一次针对性的export*/\r\nexport function addExport<T>(proxy :anyObject, dataInstance :data<T>, func :exportFunc, target? :Node) :shouldExportA{\r\n    const sE = dataInstance.shouldExports;\r\n    checkArrowFunction(func);\r\n    //检测shouldExport里是不是已经有了完全相同的函数。很不幸，由于添加了target，我们需要手动遍历数组了\r\n    //important:这里的函数还是原函数，不能bind，不然后面查重就失效了，我们等到用的时候再bind也不迟，并且分析函数还需要bind不同的东西\r\n    let isDuplicated = false;\r\n    for(let i = 0; i < sE.length; i++) if(sE[i][0] === func){\r\n        isDuplicated = true;\r\n        break;\r\n    }\r\n    if(isDuplicated) console.warn(\"Duplicated function\", func, \"is blocked being added to data\", dataInstance);\r\n    else{\r\n        const exportInstance :exportInstance = [func, target, false];\r\n        sE.push(exportInstance);\r\n        //在这里会立即引发一次针对性的export，oldValue与现在的value相同\r\n        //内置export方法大部分已经通过对比value和oldValue过滤掉了这次调用（但不能完全过滤）\r\n        func.call(proxy, exportInstance, dataInstance.value);\r\n    }\r\n    //不要让外部获取真正的引用地址\r\n    return [...sE];\r\n}\r\n/**检测函数是否是箭头函数。箭头函数拿不到this，一定会出错*/\r\nexport function checkArrowFunction(func :Function) :void{\r\n    if(FtoString.call(func).match(/^\\([^\\(\\)]*\\)[\\s]*=>/)) utils.generic.E(\"func\", undefined, func, \"this function must not be an arrow function\");\r\n}\r\nexport function removeExport<T>(dataInstance :data<T>, func :string | exportFunc) :shouldExportA{\r\n    const sE = dataInstance.shouldExports;\r\n    if(typeof func == \"string\"){\r\n        //2022.8.30改用Symbol()保存内部函数，已不需要该判断\r\n        //if(func == \"__addedByDynamic__\") utils.generic.E(\"func\", \"string | exportFunc\", func, \"this name is reserved\");\r\n        if(func == \"\") console.warn(\"Operation blocked trying to remove ALL annoymous functions. Use the function itself for argument instead.\");\r\n        //注意这里会删除所有同名函数！\r\n        else for(let i = 0; i < sE.length; i++) if(sE[i][0].name === func) utils.generic.precisePop(sE[i], sE);\r\n    }\r\n    //由于添加了target，这里需要遍历数组\r\n    else if(typeof func == \"function\") for(let i = 0; i < sE.length; i++) if(sE[i][0] === func) utils.generic.precisePop(sE[i], sE); //不是exportFunc没关系；precisePop已经处理了-1\r\n    else utils.generic.E(\"func\", \"string | exportFunc\", func);\r\n    //不要让外部获取真正的引用地址\r\n    return [...sE];\r\n}\r\n/**@deprecated return typeof data.value == \"function\";*/\r\nexport function isComputedProperty<T>(data :data<T>) :boolean{\r\n    return typeof data.value == \"function\";\r\n}\r\n/**静态分析目标函数访问了哪些this属性，不要对此寄予厚望！*/\r\n//fixme:有很多地方不健壮，需要修复\r\nexport function detectShouldUpdate(string :string) :shouldUpdateA{\r\n    const inQuote = {double: false, single: false, reversed: false}, result = [];\r\n    var resultAdding = false, subCursor = 0;\r\n    for(let i = 0; i < string.length; i++){\r\n        //if(string[i] == \"{\" && !functionStarted) functionStarted = true;\r\n        //if(functionStarted){\r\n        if(string[i] == \"\\\\n\"){\r\n            inQuote.double = false;\r\n            inQuote.single = false;\r\n        }\r\n        if(string[i] == \"`\" && !inQuote.single && !inQuote.double) inQuote.reversed = !inQuote.reversed;\r\n        if(string[i] == '\"' && !inQuote.single && !inQuote.reversed) inQuote.double = !inQuote.double;\r\n        if(string[i] == \"'\" && !inQuote.double && !inQuote.reversed) inQuote.single = !inQuote.single;\r\n        //todo:字符串插值\r\n        if(inQuote.reversed && string[i] == \"$\" && string[i + 1] == \"{\") processTemplate(i);\r\n        //console.log(string.substring(i - 5, i+5), inQuote);\r\n        //if(string[i] == \"]\" && subCursor != 0 && !inQuote.single && !inQuote.double && !inQuote.reversed){\r\n            //result.push(string.substring(subCursor, i - 2));\r\n            //subCursor = 0;\r\n        //}\r\n        if(!string[i].match(/[\\w$]/) && subCursor != 0 && !inQuote.single && !inQuote.double && !inQuote.reversed){\r\n            //console.log(string.substring(subCursor - 5, i + 5), string[subCursor], string[i]);\r\n            result.push(string.substring(subCursor, i));\r\n            subCursor = 0;\r\n        }\r\n        if(!inQuote.single && !inQuote.double && !inQuote.reversed \r\n         && string[i] == \"t\" && string[i + 1] == \"h\" && string[i + 2] == \"i\" && string[i + 3] == \"s\"\r\n         && string[i + 4] == \".\" //我们决定不支持[]使用变量来访问this了，因为可能引用了外部变量，我们完全不可能知道\r\n        ){\r\n            subCursor = i + 5;\r\n            i += 4; //跳过this.，不然在.那里就会出来\r\n        }\r\n    }\r\n    return utils.generic.noRepeat(result);\r\n    function processTemplate(i :number){\r\n        //todo:\r\n    }\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"./index\";\r\nimport * as cycle from \"../libs/cycle\";\r\nexport function eliminateSymbol(property :string | Symbol) :string{\r\n    if(typeof property == \"symbol\") utils.generic.E(property.toString(), \"string\", property,  \"index of Dynamic.data must not be a Symbol\");\r\n    return property as string;\r\n}\r\nconst toString = Object.prototype.toString;\r\n/**Not `JSON.stringify`, more than `JSON.stringify`.*/\r\nexport function advancedStringify(input :object) :string{\r\n    if(typeof input != \"object\") utils.generic.E(\"input\", \"object\", input);\r\n    //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#%E5%BC%82%E5%B8%B8\r\n    //用这个记录事后将不应该加双引号的类型去除双引号，避免如\"undefined\"（typeof string）和undefined（typeof undefined）都变成\"undefined\"的情况\r\n    //const patchList :[string[], string[], object[]] = [[], [], []];\r\n    if(input === null) return \"null\"; //不要{}了\r\n    else{\r\n        let result :string = \"{\";\r\n        //我们只对元素本身的、可枚举的属性进行提取，即Object.keys得到的东西。\r\n        const properties = Object.keys(input), toStringed = compatibleToString(input);\r\n        if(properties.length == 0){\r\n            if(toStringed != \"[object Object]\") return toStringed;\r\n            else return \"{}\";\r\n        }\r\n        else{\r\n            const input_ = cycle.decycle(input) as anyObject;\r\n            for(let i = 0; i < properties.length; i++){\r\n                const key = properties[i], value = input_[key], type = typeof value;\r\n                if(type == \"undefined\" || type == \"number\" || type == \"boolean\") addResult(value);\r\n                else if(type == \"string\") addResult(`\"${value}\"`); //字符串是带双引号的\r\n                else if(type == \"bigint\") addResult(value + \"n\");\r\n                else if(type == \"symbol\") addResult(value.toString()); //symbol不能隐式转换为字符串，又不能用in运算符\r\n                else if(type == \"function\") addResult(compatibleToString(value));\r\n                else if(type == \"object\") addResult(advancedStringify(value));\r\n                //else utils.generic.EE(\"?\"); 这个如果真走到了那世界可以毁灭了\r\n                if(i < properties.length - 1) result += \", \";\r\n                function addResult(input2 :any) :void{\r\n                    result += `${key}: ${input2}`;\r\n                }\r\n            }\r\n            result += \"}\";\r\n            return result;\r\n        }\r\n    }\r\n}\r\nexport function compatibleToString(input :object) :string{\r\n    //typeof undefined不能in\r\n    //typeof number™也不能in？？？那只能在前面兼容了\r\n    return \"toString\" in input ? input.toString() : toString.call(input);\r\n}\r\nexport function noErrorDefineProperties(obj :object, properties :PropertyDescriptorMap) :void{\r\n    for(let i in properties) if(!(i in obj)) Object.defineProperty(obj, i, properties[i]);\r\n}","/* cycle.js 2021-05-31 Public Domain. NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK. This code should be minified before deployment. See https://www.crockford.com/jsmin.html. USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO NOT CONTROL.*/\r\n/* library of dynamic\r\n * dynamic ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../../utils/index\";\r\nimport * as lUtils from \"../utils/index\";\r\n/**Make a deep copy of an object or array, assuring that there is at most one instance of each object or array in the resulting structure. The duplicate references (which might be forming cycles) are replaced with an object of the form {\"$ref\": PATH} where the PATH is a JSONPath string that locates the first occurance.\r\n * \r\n * So,`var a = [];a[0] = a;return JSON.stringify(JSON.decycle(a));`produces the string '[{\"$ref\":\"$\"}]'.\r\n * \r\n * JSONPath is used to locate the unique object. $ indicates the top level of the object or array.\r\n * \r\n * [NUMBER] or [STRING] indicates a child element or property.*/\r\nexport function decycle(object :object) :object{\r\n    const objects = new WeakMap<object, string>(); //WeakMap：96.59%（2022.8.22）\r\n    return(function checkCycle(object :object, path :string){\r\n        if( //过滤阴间object\r\n            typeof object === \"object\"\r\n         && object !== null\r\n         && !(object instanceof Boolean)\r\n         && !(object instanceof Date)\r\n         && !(object instanceof Number)\r\n         && !(object instanceof RegExp)\r\n         && !(object instanceof String)\r\n        ){\r\n            const prev_path = objects.get(object);\r\n            //如果在存储中已经有了对应的唯一值，那么就存在循环引用…………………………？，返回$ref：那个值的路径\r\n            //fixed:仅当路径存在相同部分时，我们才能走回原点，这样才存在循环引用\r\n            if(prev_path !== undefined && path.indexOf(prev_path) != -1) return {$ref: prev_path};\r\n            else objects.set(object, path); //否则加入将这个值和路径加入存储\r\n            //进入对象或数组，递归\r\n            if(object instanceof Array){\r\n                const newObj :any[] = [];\r\n                for(let i = 0; i < object.length; i++) newObj[i] = checkCycle(object[i], path + \"[\" + i + \"]\");\r\n                return newObj;\r\n            }\r\n            else{\r\n                const newObj :anyObject = {}, keys = Object.keys(object);\r\n                if(keys.length != 0) for(let i = 0; i < keys.length; i++) newObj[keys[i]] = checkCycle((object as anyObject)[keys[i]], path + \"[\" + JSON.stringify(keys[i]) + \"]\");\r\n                else{\r\n                    const toStringed = lUtils.misc.compatibleToString(object);\r\n                    if(toStringed != \"[object Object]\") return object;\r\n                    //else return newObj;\r\n                }\r\n                return newObj;\r\n            }\r\n        }\r\n        else return object;\r\n    }(object, \"$\"));\r\n};\r\n/*export function retrocycle($: any){\r\n// Restore an object that was reduced by decycle. Members whose values are\r\n// objects of the form\r\n//      {$ref: PATH}\r\n// are replaced with references to the value found by the PATH. This will\r\n// restore cycles. The object will be mutated.\r\n\r\n// The eval function is used to locate the values described by a PATH. The\r\n// root object is kept in a $ variable. A regular expression is used to\r\n// assure that the PATH is extremely well formed. The regexp contains nested\r\n// * quantifiers. That has been known to have extremely bad performance\r\n// problems on some browsers for very long strings. A PATH is expected to be\r\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\r\n// Goessner's JSONPath.\r\n\r\n// So,\r\n//      var s = '[{\"$ref\":\"$\"}]';\r\n//      return JSON.retrocycle(JSON.parse(s));\r\n// produces an array containing a single element which is the array itself.\r\n    const px = /^\\$(?:\\[(?:\\d+|\"(?:[^\\\\\"\\u0000-\\u001f]|\\\\(?:[\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\")\\])*$/;\r\n    (function rez(value){\r\n// The rez function walks recursively through the object looking for $ref\r\n// properties. When it finds one that has a value that is a path, then it\r\n// replaces the $ref object with a reference to the value that is found by\r\n// the path.\r\n        if(value && typeof value === \"object\"){\r\n            if(Array.isArray(value)){\r\n                value.forEach((element, i)=>{\r\n                    if(typeof element === \"object\" && element !== null){\r\n                        const path = element.$ref;\r\n                        if(typeof path === \"string\" && px.test(path)) value[i] = eval(path);\r\n                        else rez(element);\r\n                    }\r\n                });\r\n            }\r\n            else{\r\n                Object.keys(value).forEach(key=>{\r\n                    const item = value[key];\r\n                    if(typeof item === \"object\" && item !== null){\r\n                        const path = item.$ref;\r\n                        if(typeof path === \"string\" && px.test(path)) value[key] = eval(path);\r\n                        else rez(item);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    })($);\r\n    return $;\r\n};*/","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nconst version = \"1.0.0\";\r\n\r\n//开发模式\r\nconsole.info(\r\n`dynamic(dnJS) v${version} ©LJM12914. https://github.com/wheelsmake/dynamic\r\nYou are using the unminified build of dynamic. Make sure to use the minified build for production.`);\r\n\r\nconst\r\n//HTML声明式语法设置（不喜欢目前语法的开发者可以fork后自己直接改动这里！）\r\n    HTMLDSLs = {\r\n        two: {\r\n            l: \"_:\",\r\n            r: \":_\"\r\n        },\r\n        one: {\r\n            l: \"_-\",\r\n            r: \"-_\"\r\n        },\r\n        attr: \":\" //这个玩意的位置配置不在这里，在#hydrate里面，懒得提出来了\r\n    },\r\n    twoWayBindingRegExp = new RegExp(`^${HTMLDSLs.two.l}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.two.r}$`),\r\n    oneWayBindingRegExp = new RegExp(`^${HTMLDSLs.one.l}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.one.r}$`),\r\n    //下面这个是用来检查开发者的错误的\r\n    nStwoWayBindingRegExp = new RegExp(`${HTMLDSLs.two.l}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.two.r}`, \"g\"),\r\n    nSoneWayBindingRegExp = new RegExp(`${HTMLDSLs.one.l}[a-zA-Z$_][\\\\w$]*${HTMLDSLs.one.r}`, \"g\"),\r\n\r\n//字符串重用\r\n    s :string[] = [\r\n        \"鬼片出现了！\",\r\n        \"Access to deleted property was blocked: \",\r\n        \", automatically treated as one-way binding.\",\r\n        \"function\"\r\n    ];\r\n\r\n\r\n//主类\r\nexport default class App{\r\n//#region 基本功能\r\n    constructor(rootNode :Elementy){\r\n        this.#rootNode = utils.arguments.reduceToElement(rootNode)!;\r\n        console.info(\"creating new dynamic instance with rootNode\", rootNode);\r\n        this.#hydrate(this.#rootNode);\r\n        //不用观察自己对DOM的修改\r\n        this.#observer.observe(this.#rootNode, {\r\n            attributes: true,\r\n            attributeOldValue: true,\r\n            characterData: true,\r\n            characterDataOldValue: true,\r\n            childList: true,\r\n            subtree: true\r\n        });\r\n    }\r\n    #rootNode :Element;\r\n    get rootNode(){return this.#rootNode;}\r\n//#endregion\r\n\r\n//#region DOM监控系统\r\n    //WeakMap：96.59%（2022.8.22）\r\n    #aOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    #dOProcessorStore = new WeakMap<Node, MRProcessorFn>();\r\n    #cOProcessorStore = new WeakMap<Element, MRProcessorFn>();\r\n    //get dOProcessorStore(){return this.#dOProcessorStore};\r\n    //简单的DOM监控回调机制，全看对面MRProcessorFn设计得如何\r\n    #observer :MutationObserver = new MutationObserver((records :MutationRecord[])=>{\r\n        for(let i = 0; i < records.length; i++){\r\n            const record = records[i], type = record.type;\r\n            //console.log(record);\r\n            //既然有attribute那肯定是Element\r\n            if(type == \"attributes\" && this.#aOProcessorStore.has(record.target as Element)) this.#aOProcessorStore.get(record.target as Element)!(record);\r\n            else if(type == \"characterData\" && this.#dOProcessorStore.has(record.target)) this.#dOProcessorStore.get(record.target)!(record);\r\n            //既然有childList那肯定是Element\r\n            else if(type == \"childList\" && this.#cOProcessorStore.has(record.target as Element)) this.#cOProcessorStore.get(record.target as Element)!(record);\r\n            //else\r\n        }\r\n    });\r\n//#endregion\r\n\r\n//#region 数据管理\r\n    #data :dataObject = {};\r\n    //proxy本身没有不可变性，必须再用一个data只读伪属性保护 //class内部不要引用这个data！内部为什么不直接引用#proxy呢？？？？？\r\n    get data(){return this.#proxy;}\r\n    get _(){return this.#proxy;}\r\n    //proxy虽然代理了#data这个dataObject，但它的表现其实就是一个典型的、完整的anyObject\r\n    #proxy :anyObject = new Proxy(this.#data, {\r\n        get(sharpData :dataObject, property :string | symbol, proxy :anyObject) :any{\r\n            property = lUtils.misc.eliminateSymbol(property);\r\n            //console.log(\"get\", property);\r\n            //正常存在该属性\r\n            if(property in sharpData && !sharpData[property].deleted){\r\n                let result :any;\r\n                //如果是“计算”属性就返回缓存值\r\n                if(typeof sharpData[property].value == s[3]) result = sharpData[property].cache;\r\n                else result = sharpData[property].value;\r\n                //不要在这边优化object显示，这边是有啥输出啥！人家传一个object进来，你给他一个string回去？？？正确的方法是在textContent替换中写object！\r\n                return result;\r\n            }\r\n            //不用创建属性！\r\n            else if(!(property in sharpData)) return undefined;\r\n            //该属性已被删除fixed:这个不能放在没有该属性前，reading undefined警告\r\n            else if(sharpData[property].deleted) console.warn(`${s[1]}${property}.`);\r\n            else console.error(s[0], \"get\", property); //不可能有else了……？\r\n        },\r\n        set(sharpData :dataObject, property :string | symbol, newValue :unknown, proxy :anyObject) :boolean{\r\n            property = lUtils.misc.eliminateSymbol(property);\r\n            //console.log(\"set\", property, newValue);\r\n            //正常存在该属性\r\n            if(property in sharpData && !sharpData[property].deleted){\r\n                //如果传入的是函数，那么就收集函数中需要的属性，将这些属性的shouldUpdate中推一个这个属性\r\n                //`a.shouldUpdate[number] = \"b\"` 的意思是：当属性a发生改变时，要去更新b\r\n                //更新b并不是运行一次b.value函数，而是去更新b.shouldExport，重新运行一遍这些方法，将DOM中的b更新\r\n                //我们也要同样地去b.shouldUpdate里将它们的shouldExport运行了，因为它们的值也“应该”改变了\r\n                //这是一个递归过程，一直从shouldUpdate下去，一直运行shouldExport\r\n                const oldValue = sharpData[property].value;\r\n                if(oldValue !== newValue){ //要是前后相同，那为什么还要更新呢？——嫖怪\r\n                    sharpData[property].value = newValue;\r\n                    processComputedProperty(sharpData[property]);\r\n                    //导出数据\r\n                    const exportInstances = sharpData[property].shouldExports;\r\n                    for(let i = 0; i < exportInstances.length; i++) exportInstances[i][0].call(proxy, exportInstances[i], oldValue);\r\n                    //更新需要更新的属性\r\n                    //console.log(\"update\"+property, sharpData[property].shouldUpdates);\r\n                    for(let i = 0; i < sharpData[property].shouldUpdates.length; i++) dfsUpdate(sharpData[property].shouldUpdates[i]);\r\n                    function dfsUpdate(prop :string) :void{\r\n                        if(prop in sharpData && typeof sharpData[prop].value == s[3]){ //找到计算属性\r\n                            const dfsOldValue = sharpData[prop].cache; //记录旧数据\r\n                            sharpData[prop].cache = sharpData[prop].value.call(proxy); //更新“计算”属性的缓存\r\n                            //导出数据\r\n                            const exportInstances = sharpData[prop].shouldExports;\r\n                            for(let i = 0; i < exportInstances.length; i++) exportInstances[i][0].call(proxy, exportInstances[i], dfsOldValue);\r\n                            //递归\r\n                            for(let i = 0; i < sharpData[prop].shouldUpdates.length; i++) dfsUpdate(sharpData[prop].shouldUpdates[i]);\r\n                        }\r\n                    }\r\n                }\r\n                //阴间功能：将计算属性赋值给它自己会触发重新计算lUtils.data.checkArrowFunction(newValue as Function);\r\n                //太阴间了，会导致将cache赋给value，不要了\r\n                //else if(typeof newValue == s[3]) sharpData[property].cache = \r\n                else console.log(`Update skipped in ${property} for same value ${newValue}`);\r\n            }\r\n            //尚未有该属性，新建\r\n            else if(!(property in sharpData)){\r\n                sharpData[property] = lUtils.data.createData(newValue);\r\n                processComputedProperty(sharpData[property]);\r\n            }\r\n            //该属性已被删除fixed:这个不能放在没有该属性前，reading undefined警告\r\n            else if(sharpData[property].deleted) console.warn(`${s[1]}${property}.`);\r\n            else console.error(s[0], \"set\", property); //不可能有else了\r\n            return true;\r\n            /**建立cache，执行计算，分析函数，修改shouldUpdates，否则删除cache*/\r\n            function processComputedProperty<T>(dataInstance :data<T>) :void{\r\n                property = lUtils.misc.eliminateSymbol(property);\r\n                if(typeof newValue == s[3]){\r\n                    lUtils.data.checkArrowFunction(newValue as Function);\r\n                    dataInstance.cache = (newValue as Function).call(proxy);\r\n                    const shouldUpdateThis = lUtils.data.detectShouldUpdate(Function.prototype.toString.call(newValue));\r\n                    //console.log(shouldUpdateThis, property);\r\n                    for(let i = 0; i < shouldUpdateThis.length; i++){\r\n                        //如果函数中访问了还没有创建的属性，那么我们只能去创建它，因为shouldUpdateA不能在之后补上。其实正确的做法是先不创建的\r\n                        if(!(shouldUpdateThis[i] in sharpData)) proxy[shouldUpdateThis[i]] = undefined;\r\n                        if(sharpData[shouldUpdateThis[i]].shouldUpdates.indexOf(property) == -1) sharpData[shouldUpdateThis[i]].shouldUpdates.push(property);\r\n                    }\r\n                }\r\n                //将“计算”属性变成普通属性，反正delete不报错，随便操作\r\n                else delete dataInstance.cache;\r\n            }\r\n        },\r\n        //用has拦截in运算没必要，因其不会导致#data状态的改变，并且in是可以完全正常使用的\r\n        //Proxy的defineProperty只会在Object.defineProperty走到，别听MDN的\r\n        //https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/defineProperty#:~:text=proxy.property%3D%27value%27\r\n        //只要警告他们不要用Object.defineProperty往data里扔东西就好了\r\n        //由于需要获取proxy，我们只能用箭头函数了\r\n        deleteProperty: (sharpData :dataObject, property :string | symbol) :boolean=>{\r\n            //reviewed:不要真正删除而是标记删除\r\n            property = lUtils.misc.eliminateSymbol(property);\r\n            const exists = property in sharpData;\r\n            if(exists){\r\n                //重置值\r\n                this.#proxy[property] = undefined;\r\n                sharpData[property].deleted = true;\r\n            }\r\n            return exists;\r\n        }\r\n    });\r\n    //这几个必须使用#data得到完整的data实例\r\n    addExport(dataProperty :string, func :exportFunc, target :Node) :shouldExportA{return lUtils.data.addExport(this.#proxy, this.#data[dataProperty], func, target);}\r\n    removeExport(dataProperty :string, func :string | exportFunc) :shouldExportA{return lUtils.data.removeExport(this.#data[dataProperty], func);}\r\n    getExports(dataProperty :string) :shouldExportA{return [...this.#data[dataProperty].shouldExports];}\r\n//#endregion\r\n\r\n//#region 实例内方法\r\n    #methods :functionObject = {};\r\n    #methodsProxy = new Proxy(this.#methods, {\r\n        //reviewed:为了获取#proxy我们只能使用箭头函数了，不知道会不会出问题\r\n        get: (sharpMethods, property, proxy)=>{\r\n            property = lUtils.misc.eliminateSymbol(property);\r\n            if(property in sharpMethods) return sharpMethods[property].bind(this.#proxy);\r\n            else return undefined;\r\n        }/*,\r\n        set(sharpMethods, property, newValue, proxy){\r\n            property = lUtils.misc.eliminateSymbol(property);\r\n            //if(property in sharpMethods) console.warn(`Avoid changing methods`); //感觉改方法挺常见的\r\n            sharpMethods[property] = newValue;\r\n            return true;\r\n        }*/\r\n    });\r\n    get methods(){return this.#methodsProxy;}\r\n    get $(){return this.#methodsProxy;}\r\n//#endregion\r\n\r\n//#region HTML声明式语法\r\n    //外部访问\r\n    hydrate(node :Nody) :void{\r\n        node = utils.arguments.reduceToNode(node)!;\r\n        //不要扩展作用域\r\n        if(/*utils.element.isDescendant(node, this.#rootNode)*/this.#rootNode.contains(node)) this.#hydrate(node);\r\n        else utils.generic.E(\"node\", undefined, node, \"the input node must be a descendant of the rootNode\");\r\n    }\r\n    #hydrate(node :Node) :void{\r\n        if(node instanceof Element){\r\n            //hack:超级hack完美解决作用域内部元素on*事件必须访问全局App才能访问数据的问题\r\n            //给作用域内每个元素的data和_都弄上这个data，然后只要this一下就出来了！\r\n            const data = this.data, methods = this.methods;\r\n            lUtils.misc.noErrorDefineProperties(node, {\r\n                data: {\r\n                    configurable: false,\r\n                    enumerable: true,\r\n                    get(){return data;}\r\n                },\r\n                _: {\r\n                    configurable: false,\r\n                    enumerable: true,\r\n                    get(){return data;}\r\n                },\r\n                methods: {\r\n                    configurable: false,\r\n                    enumerable: true,\r\n                    get(){return methods;}\r\n                },\r\n                $: {\r\n                    configurable: false,\r\n                    enumerable: true,\r\n                    get(){return methods;}\r\n                }\r\n            });\r\n            const attrs = Array.from(node.attributes), children = Array.from(node.childNodes) as Node[];\r\n            //记录必要信息，在遍历完所有属性后再执行破坏性操作，保证这个for循环是纯函数\r\n            const tasks :[1 | 2, string, string, string][] = [];\r\n            for(let i = 0; i < attrs.length; i++){\r\n                //#region 关于attribute与property的讨论\r\n                /*important:fixed:对于某些attribute来说，它们本身只是一个默认值，想要获得真正的值需要访问节点的对应property！\r\n                但是我们无法知道哪些attribute有这种阴间问题，到时候一味更新attribute没更新到property就没用了\r\n                目前看了看标准和文档，来试图真正说清楚这个。\r\n                我们将property/attribute组合叫pa组合，将 $0[property] = x会导致$0.getAttribute(\"property\") === x 称为 拥有完整的p->a同步，将 $0.setAttribute(\"property\", x)会导致$0[property] === x 称为 拥有完整的a->p同步，将拥有完整的p->a同步和拥有完整的a->p同步称为完全双向同步，拥有两者中任一种称为单向同步。\r\n                如果存在同步，但property的值需要改变，那么称为非同名同步。\r\n                pa组合一共有以下几种：1. 同名且完全双向同步，如accept。2. 不同名且完全双向同步，如value(a)和defaultValue(p)。3. 不同名且不可能双向同步，因为两边的格式不同，如style。但是这种情况下浏览器已经做好了转换，可以近似视作第二种。\r\n                由此可见pa组合一定存在双向同步，这和whatwg.org的标准是完全相符的；但是可能名字不同。这个名字不同问题很大，因为有的只是kebab转camel，有的整个都变了，如value->defaultValue，class->className。\r\n                并且有的不同组合的a和p存在一次性的同步，这个“一次性”发生在第一次加载页面（Gecko和IE）或每次刷新页面（chromium）\r\n                例如value(a)和value(p)，它们不是一个组合（value(a)和defaultValue(p)才是一对的），一次性同步方向为value(a)->value(p)。\r\n                我们的目的是：能够做到属性值与data双向同步，即修改属性值会触发data修改且触发data should*事件，修改data触发属性值的修改。\r\n                然而property不能被监控，只有attribute可以用observer监控，所以我们只能用常规方法做到存在与之对应的attribute的property的响应式\r\n                像<input>中的value和checked这两个property，没有对应的attribute，于是我们必须用另一种方法：直接设置property。\r\n                我们也不能通过observer实现双向绑定，但还好浏览器提供了oninput事件，可以用这个补回去。\r\n                于是可以做了！\r\n                参考链接：\r\n                https://javascript.info/dom-attributes-and-properties#:~:text=But%20there%20are%20exclusions\r\n                https://stackoverflow.com/questions/57475325\r\n                https://html.spec.whatwg.org/multipage/common-dom-interfaces.html#reflecting-content-attributes-in-idl-attributes\r\n                */\r\n                //#endregion\r\n                \r\n                let name = attrs[i].name, value = attrs[i].value; //???:这里不能用var？不同次for之间居然能共享var变量？\r\n                const nameOne = !!name.match(oneWayBindingRegExp),\r\n                      nameTwo = !!name.match(twoWayBindingRegExp),\r\n                      valueOne = !!value.match(oneWayBindingRegExp),\r\n                      valueTwo = !!value.match(twoWayBindingRegExp),\r\n                      nameInserted = nameOne || nameTwo,\r\n                      valueInserted = valueOne || valueTwo;\r\n                let name_property :string,\r\n                    value_property :string,\r\n                    //这两个和name一起构成了一个筛查链条：如果有${HTMLDSLs.attrAdditional}，那么%2和%1不同，如果有default陷阱那么%3也和%2不同\r\n                    //最终%3是真正在设置的东西\r\n                    processed_avoidance_name :string,\r\n                    processed_avoidance_defaultTrap_name :string;\r\n                \r\n                //各种警告\r\n                if(nameTwo) console.warn(`It's not rational to declare a two-way binding attribute name: ${name}${s[2]} Use \"${HTMLDSLs.one.l}${name.substring(2, name.length - 2)}${HTMLDSLs.one.r}\" instead.`);\r\n                //这个还是不能允许\r\n                if(nameInserted && valueInserted) console.warn(\"Cannot set an attribute with both name and value dynamic. Dynamic will make only attribute name dynamic.\");\r\n                \r\n                //属性名和属性值都要求全部是插值，不允许中途插值；其中属性值支持双向绑定\r\n                if(nameInserted){ //处理属性名\r\n                    name_property = name.substring(2, name.length - 2);\r\n                    //更新attribute的名称，值不改变；但是本质上是删除旧attribute，添加新attribute；因此必须需要一个参数，否则无从得知是哪个attribute\r\n                    const symbol = Symbol();\r\n                    const funcObj = {\r\n                        [symbol]: function(this :anyObject, exportInstance :exportInstance, oldValue :string){ //参数里放this不影响函数的参数\r\n                            const newValue = this[name_property];\r\n                            //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                            if(oldValue !== newValue){\r\n                                const thisNode = exportInstance[1] as Element,\r\n                                valueOfAttr = thisNode.getAttribute(oldValue)!;\r\n                                //要先删除，因为setAttribute可能会出错，出错了就会多一个attribute\r\n                                //出错后再次设置数据属性的值时，如果成功设置了attr，attr值也会是null，因为上次没有成功，旧的attr值直接没了，这完全符合预期！\r\n                                thisNode.removeAttribute(oldValue);\r\n                                if(newValue !== \"\"){\r\n                                    //警告开（我）发（自）者（己）不要传大写字母进属性名\r\n                                    if(typeof newValue == \"string\" && newValue !== newValue.toLowerCase()) console.warn(`Attribute names are case insensitive, don't pass string with upper-case letters which may cause bugs: ${newValue}`);\r\n                                    thisNode.setAttribute(newValue, valueOfAttr);\r\n                                }\r\n                                //else \"\"不是有效的属性名称，所以我们将它视为属性被动态删除了\r\n                            }\r\n                            //else return; //值没有改变，直接返回\r\n                        }\r\n                    };\r\n                    if(!(name_property in this.#proxy)) this.#proxy[name_property] = undefined; //创建属性\r\n                    lUtils.data.addExport(this.#proxy, this.#data[name_property], funcObj[symbol], node); //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                }\r\n                else if(valueInserted){ //处理属性值\r\n                    value_property = value.substring(2, value.length - 2);\r\n                    //筛查规避属性\r\n                    if(name[name.length - 1] == HTMLDSLs.attr) processed_avoidance_name = name.substring(0, name.length - 1);\r\n                    else processed_avoidance_name = name;\r\n                    let funcObj :functionObject = {};\r\n                    if( //特殊attribute/property处理\r\n                        (processed_avoidance_name == \"value\" || processed_avoidance_name == \"checked\")\r\n                     && node instanceof HTMLInputElement //避免其他元素上可能存在这些开发者自定义的属性，造成干扰\r\n                     && processed_avoidance_name in node //这个东西感觉没啥作用，其实只是加个保险。检测是否存在对应property，似乎value真的在input的原型链上而不是它本身的属性\r\n                    ) funcObj.func = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                        const newValue = this[value_property];\r\n                        //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                        if(oldValue !== newValue) (node as anyObject)[processed_avoidance_name] = newValue;\r\n                    }\r\n                    else{\r\n                        //处理上一个if过滤掉的对称情况\r\n                        if(node instanceof HTMLInputElement){\r\n                            //快死了，乱转大写小写的\r\n                            if(processed_avoidance_name == \"defaultvalue\" && \"defaultValue\" in node) processed_avoidance_defaultTrap_name = \"value\";\r\n                            else if(processed_avoidance_name == \"defaultchecked\" && \"defaultChecked\" in node) processed_avoidance_defaultTrap_name = \"checked\";\r\n                            else processed_avoidance_defaultTrap_name = processed_avoidance_name;\r\n                        }\r\n                        else processed_avoidance_defaultTrap_name = processed_avoidance_name;\r\n                        funcObj.func = function(this :anyObject, exportInstance :exportInstance, oldValue :any){\r\n                            const newValue = this[value_property];\r\n                            //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                            if(oldValue !== newValue){\r\n                                //我们将null视为属性被动态删除了\r\n                                if(newValue === null) node.removeAttribute(processed_avoidance_defaultTrap_name); //setAttribute删不掉\r\n                                else node.setAttribute(processed_avoidance_defaultTrap_name, newValue);\r\n                            } \r\n                            //else 值没有改变，直接返回\r\n                        }\r\n                    }\r\n                    if(!(value_property in this.#proxy)) this.#proxy[value_property] = undefined; //创建属性\r\n                    lUtils.data.addExport(this.#proxy, this.#data[value_property], funcObj.func, node); //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                    //#region 双向绑定补丁\r\n                    if(valueTwo){\r\n                        //特别处理这几个东西，就是这里需要用到原始的name\r\n                        if(node instanceof HTMLInputElement){\r\n                            if(name == \"value\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) this.#proxy[value_property] = node.value;\r\n                                });\r\n                            }\r\n                            else if(name == \"checked\"){\r\n                                node.addEventListener(\"input\", (e :Event)=>{\r\n                                    if(e.target === node) this.#proxy[value_property] = node.checked;\r\n                                });\r\n                            }\r\n                            //else if(name == \"defaultValue\") 不需要了，跟着下面去监听就行了\r\n                        }\r\n                        else{\r\n                            this.#aOProcessorStore.set(node, (record: MutationRecord)=>{\r\n                                //使用record.target而不是node，否则会增加内存占用\r\n                                if(\r\n                                    record.attributeName === processed_avoidance_defaultTrap_name\r\n                                //只有在attribute值和数据属性的值不一样的时候才需要同步，否则会导致无限同步\r\n                                 && (record.target as Element).getAttribute(record.attributeName!) !== this.#proxy[value_property]\r\n                                ) this.#proxy[value_property] = (record.target as Element).getAttribute(record.attributeName!);\r\n                            });\r\n                        }\r\n                    }\r\n                    //#endregion\r\n                }\r\n                //else\r\n\r\n                //录入破坏性任务\r\n                if(nameInserted) tasks.push([1, name, name_property!, value]);\r\n                else if(valueInserted) tasks.push([2, name, processed_avoidance_defaultTrap_name!, value_property!]);\r\n            }\r\n\r\n            //执行破坏性任务\r\n            for(let i = 0; i < tasks.length; i++){\r\n                const taskInstance = tasks[i];\r\n                if(taskInstance[0] == 1){ //属性名匹配\r\n                    node.removeAttribute(taskInstance[1]); //删除旧属性\r\n                    //这个不能用__addedByDynamic__代替，因为它出于性能原因会检查属性值是否没有改变\r\n                    node.setAttribute(this.#proxy[taskInstance[2]], taskInstance[3]); //将value搬迁到新的attribute中\r\n                }\r\n                else if(taskInstance[0] == 2){ //属性值匹配\r\n                    //是特殊attribute/property，不应setAttr而应修改property\r\n                    if(taskInstance[2] === undefined) (node as anyObject)[taskInstance[1]] = this.#proxy[taskInstance[3]];\r\n                    //这个不能用__addedByDynamic__代替，因为它出于性能原因会检查属性值是否没有改变\r\n                    else{\r\n                        node.removeAttribute(taskInstance[1]); //使用最初的name来删除旧属性\r\n                        node.setAttribute(taskInstance[2], this.#proxy[taskInstance[3]]); //将数据属性的值export一次\r\n                    }\r\n                }\r\n                //else\r\n            }\r\n\r\n            //进入子节点\r\n            for(let i = 0; i < children.length; i++) this.#hydrate(children[i]);\r\n        }\r\n        else if(node instanceof Text){ //fixed:如果修改Element的textContent则会覆盖所有子元素，所以我们仅在文本节点上执行这边的代码\r\n            if(node.textContent){\r\n                //双向绑定直接视为单向绑定并警告\r\n                const text = node.textContent, twoWayInserts = [...text.matchAll(nStwoWayBindingRegExp)],\r\n                      inserts = [...text.matchAll(nSoneWayBindingRegExp),...twoWayInserts],\r\n                      matchTwoWayBinding = !!text.match(twoWayBindingRegExp),\r\n                      matchOneWayBinding = !!text.match(oneWayBindingRegExp);\r\n                if(twoWayInserts.length > 0 && !matchTwoWayBinding) console.warn(`Two-way bindings in \"${text}\" cannot be used in textContent template${s[2]}`);\r\n\r\n                //textContent双向绑定，只有单向绑定支持模板，双向绑定是不支持的，必须全都是并且是整个元素全都是，不允许出现其他兄弟节点\r\n                //这种情况需要先判断，因为后一种情况包含了这一种情况\r\n                if(matchTwoWayBinding){\r\n                    //fuck:我要爆粗口了！TS没十年脑溢血写不出来啊！你™parentElement返回类型HTMLElement？？？\r\n                    //有生之年我居然在判断HTMLElement instanceof HTMLElement！\r\n                    //并且ts还号称要平衡生产力和准确性，不修这个问题！2015年的老issue了https://github.com/microsoft/TypeScript/issues/4689#issuecomment-146324456\r\n                    if(!(node.parentElement! instanceof HTMLElement)) console.warn(\"It's no use adding a two-way binding insert to an SVGElement, but dynamic will continue anyway.\");\r\n                    const property = text.substring(2, text.length - 2),\r\n                          parent = node.parentNode!; //不可能没有parentNode！\r\n                    if(parent.childNodes.length == 1){\r\n                        const symbol = Symbol();\r\n                        const funcObj = {\r\n                            [symbol]: function(this :anyObject){\r\n                                //fixed:由于目前parent里只有一个只有一个插值Element，我们完全可以直接将内容写进parent；\r\n                                //fixme:双向绑定未实装。\r\n                                const data = this[property];\r\n                                if(parent.textContent !== data){\r\n                                    if(data instanceof Element || (data instanceof Array && data[0] instanceof Element)){\r\n                                        //review:做的比较匆忙\r\n                                        //todo:这里必须过滤数据未改动的情况，使用vDOM（未实装），否则相当于不用框架\r\n                                        (parent as Element).innerHTML = \"\";\r\n                                        if(data instanceof Element) parent.appendChild(data);\r\n                                        else for(let i = 0; i < data.length; i++){\r\n                                            if(data[i] instanceof Element) parent.appendChild(data[i]);\r\n                                            else parent.appendChild(document.createTextNode(lUtils.misc.advancedStringify(data[i])));\r\n                                        }\r\n                                        return;\r\n                                    }\r\n                                    else parent.textContent = data;\r\n                                }\r\n                                /*let t = text;\r\n                                if(!document.contains(exportInstance[1]!)){ //检查旧文本节点还在不在，这个别过滤，常回家看看他不香吗？\r\n                                    let oldNode = exportInstance[1]!;\r\n                                    exportInstance[1] = document.createTextNode(t); //text是模板字符串，要用text才能replaceAll\r\n                                    parent.appendChild(exportInstance[1]); //随便，反正就一个节点\r\n                                }\r\n                                let thisNode = exportInstance[1]!, data = this[property];\r\n                                //过滤oldValue和newValue相同的情况（类型不同的话不能做到完全过滤）\r\n                                if(data !== oldValue){\r\n                                    //fixed:见initData()->Proxy->set\r\n                                    if(typeof data == \"object\") data = lUtils.misc.advancedStringify(data);\r\n                                    //todo:输出HTML DOM\r\n                                    t = t.replaceAll(`${HTMLDSLs.twoWayBinding.leftBracket}${property}${HTMLDSLs.twoWayBinding.rightBracket}`, data);\r\n                                    //上面不能做到完全过滤，所以这里来个终极过滤\r\n                                    if(thisNode.textContent !== t) thisNode.textContent = t; //不修改innerText而是修改textContent，因为innerText会每次都触发浏览器绘制过程\r\n                                }*/\r\n                            }\r\n                        };\r\n                        if(!(property in this.#proxy)) this.#proxy[property] = undefined; //创建属性\r\n                        lUtils.data.addExport(this.#proxy, this.#data[property], funcObj[symbol], node);\r\n                        //fixed:note:已经验证：chromium会乱搞文本节点，具体内容是：\r\n                        //仅在chromium中：两个文本节点在一起，在开发者工具中编辑前面那个后后面那个的内容会加到前面，后面那个被删，编辑后面那个会将前面那个删掉。\r\n                        //设置textContent = \"\"，文本节点不会被删。\r\n                        //contenteditable后内容被用户清空，文本节点不会被删。仅在chromium中：再输入内容时重建的是另一个文本节点，即使设置了webkit-user-modify: read-write-plaintext-only。\r\n                        //因此会出现contenteditable内容清空后新内容输入到新节点的情况\r\n                        //succeed:有解决方案了！可以通过input事件从父元素获取数据！不用抓着文本节点不放了！\r\n                        parent.addEventListener(\"input\", (e :Event)=>{\r\n                            if(e.target === parent && parent.textContent !== this.#proxy[property]) this.#proxy[property] = parent.textContent;\r\n                            //todo:目前只支持文本，要支持HTML DOM双向绑定可能需要重构上面的代码\r\n                        });\r\n                        //这边需要自己上阵干掉标识\r\n                        node.textContent = this.#proxy[property];\r\n                        //console.log(document.contains(node));\r\n                    }\r\n                    else console.error(\"The parent element of a two-way binding text node must only have this text node.\");\r\n                }\r\n                //没有匹配到则为null，匹配到则[n]为${HTMLDSLs.oneWayBinding.leftBracket}example${HTMLDSLs.oneWayBinding.rightBracket}\r\n                else if(inserts.length > 0){\r\n                    //我们先确定这一段文字中所有需要的属性，然后保存好这一段文字，然后给这些属性添加export方法\r\n                    //方法的具体内容是收集所有需要的属性，用保存好的文字作模板进行逐个属性的替换，最后塞回节点里\r\n                    //succeed:通过exportInstance参数和一大堆定位常量，我们成功实现了文本节点被删除后的精确重建+正常更新！\r\n                    const /*offsets = [],*/ properties = [],\r\n                          parent = node.parentNode!, nextNode = node.nextSibling; //不可能没有parentNode！https://developer.mozilla.org/zh-CN/docs/Web/API/Node/parentNode#%E5%A4%87%E6%B3%A8\r\n                    //收集数据并创建尚未创建的属性\r\n                    for(let i = 0; i < inserts.length; i++){\r\n                        const property = inserts[i][0].substring(2, inserts[i][0].length - 2);\r\n                        //offsets.push(inserts[i].index);\r\n                        properties.push(property);\r\n                        if(!(property in this.#proxy)) this.#proxy[property] = undefined; //统一使用#proxy创建属性\r\n                    }\r\n                    //构造并记录export方法\r\n                    const NRproperties = utils.generic.noRepeat(properties);\r\n                    const symbol = Symbol();\r\n                    const funcObj = {\r\n                        [symbol]: function(this :anyObject, exportInstance :exportInstance){ //参数里放this不影响函数的参数\r\n                            const data = this[NRproperties[0]];\r\n                            if(\r\n                                (data instanceof Element\r\n                             || (data instanceof Array && data[0] instanceof Element))\r\n                             && matchOneWayBinding\r\n                            ){\r\n                                exportInstance[2] = true;\r\n                                console.log(NRproperties);\r\n                                //review:做的比较匆忙\r\n                                //todo:这里必须过滤数据未改动的情况，使用vDOM（未实装），否则相当于不用框架\r\n                                (parent as Element).innerHTML = \"\";\r\n                                if(data instanceof Element) parent.appendChild(data);\r\n                                else for(let i = 0; i < data.length; i++){\r\n                                    if(data[i] instanceof Element) parent.appendChild(data[i]);\r\n                                    else parent.appendChild(document.createTextNode(lUtils.misc.advancedStringify(data[i])));\r\n                                }\r\n                            }\r\n                            else{\r\n                                let template = text; //为了保证它是值类型，node.textContent是引用类型，会变\r\n                                if(exportInstance[2]){ //由HTML转为非HTML，创建文本节点\r\n                                    (parent as Element).innerHTML = \"\";\r\n                                    exportInstance[1] = document.createTextNode(template);\r\n                                    parent.insertBefore(exportInstance[1], nextNode);\r\n                                }\r\n                                else if(!document.contains(exportInstance[1]!)){ //检查旧文本节点还在不在\r\n                                    exportInstance[1] = document.createTextNode(template); //要用template才能replaceAll\r\n                                    parent.insertBefore(exportInstance[1], nextNode);\r\n                                }\r\n                                let thisNode = exportInstance[1]!;\r\n                                exportInstance[2] = false;\r\n                                //由于不知道调用该函数的数据属性（caller）是哪个，无法过滤数据并未改动的情况，也因此会收到addExport的调用\r\n                                for(let i = 0; i < NRproperties.length; i++){\r\n                                    let data = this[NRproperties[i]];\r\n                                    //if(data instanceof Element || data instanceof Array){//不允许在模板中输出HTML DOM\r\n                                    if(typeof data == \"object\") data = lUtils.misc.advancedStringify(data);\r\n                                    template = template //这里也需要处理双向绑定，因为模板中的双向绑定被当作是单向绑定了\r\n                                    .replaceAll(`${HTMLDSLs.one.l}${NRproperties[i]}${HTMLDSLs.one.r}`, data)\r\n                                    .replaceAll(`${HTMLDSLs.two.l}${NRproperties[i]}${HTMLDSLs.two.r}`, data);\r\n                                }\r\n                                if(thisNode.textContent !== template) thisNode.textContent = template; //不修改innerText而是修改textContent，因为innerText会每次都触发浏览器绘制过程\r\n                            }\r\n                        }\r\n                    };\r\n                    for(let i = 0; i < NRproperties.length; i++) lUtils.data.addExport(this.#proxy, this.#data[NRproperties[i]], funcObj[symbol], node); //如果已经存在数据属性那么不要随便赋值，只需要添加export即可\r\n                }\r\n                //else 其他情况不用判断\r\n            }\r\n            //else 不管空节点\r\n        }\r\n        //else console.error(s[0], node); //这里没有鬼片，注释节点会走到这里\r\n    }\r\n//#endregion\r\n}","/* utils\r\n * ©2022 LJM12914. https://github.com/wheelsmake/utils\r\n * Licensed under MIT License. https://github.com/wheelsmake/utils/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"./index\";\r\n/**一定会返回Element，void为报错hack*/\r\nexport function reduceToElement(input :Elementy) :Element | void{\r\n    if(input instanceof Element) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el as Element;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\"); //fixed:现在不会走到new Element()那儿了\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}\r\n/**一定会返回Node，void为报错hack*/\r\nexport function reduceToNode(input :Nody) :Node | void{\r\n    if(input instanceof Node) return input;\r\n    else if(typeof input == \"string\"){\r\n        const el = utils.element.e(input);\r\n        if(el instanceof Node) return el;\r\n        else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a VALID #id selector\"); //fixed:现在不会走到new Element()那儿了\r\n    }\r\n    else utils.generic.E(\"rootNode\", \"string | Element\", input, \"rootNode should be a #id selector or an Element\");\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n/*export default class Template{\r\n    \r\n}*/\r\nexport function register(){\r\n\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function getSearch() :SSkvObject | null{\r\n    var s = location.search;\r\n    if(s != \"\"){\r\n        s = s.substring(1);\r\n        const result :SSkvObject = {};\r\n        s.split(\"&\").forEach(value=>{\r\n            const sp = value.split(\"=\");\r\n            result[sp[0]] = sp[1];\r\n        });\r\n        return result;\r\n    }\r\n    else return null;\r\n}\r\nexport function getHash() :string{\r\n    return location.hash.substring(1);\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\nexport function add(){\r\n    //todo:\r\n}","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport * as utils from \"../../utils/index\";\r\nimport * as lUtils from \"./utils/index\";\r\n\r\n//分文件开发\r\nimport App from \"./app\";\r\nimport * as template from \"./template\";\r\nimport * as spa from \"./spa\";\r\nimport * as manifest from \"./manifest\";\r\n\r\n\r\n//禁用开发者工具的hack变量\r\nconst cI = clearInterval;\r\nvar dtInterval :number;\r\n//禁用开发者工具（不推荐，因此在API指引里没写）\r\nfunction __disableDevTools__() :void{\r\n    dtInterval = (()=>{\r\n        return setInterval(()=>{\r\n            debugger;\r\n        }, 20) as unknown as number; //怎么默认在NodeJS环境下呢？？？\r\n    })();\r\n    //hack clearInterval，让它不清除我们的这个\r\n    //Proxy中毒太深了，Proxy只在一大堆对象的代理上有性能优势，就这一个还不如用function\r\n    (clearInterval as any) = (id: number | undefined) :void=>{\r\n        if(id != dtInterval) cI.call(window, id);\r\n    }\r\n    /*(clearInterval as any) = new Proxy(clearInterval, {\r\n        apply(target, thisArg, argArray){\r\n            if(argArray[0] != dtInterval) return Reflect.apply(target, thisArg, argArray);\r\n        }\r\n    });*/\r\n}\r\nfunction __enableDevTools__() :void{\r\n    (clearInterval as any) = cI;\r\n    clearInterval(dtInterval);\r\n}\r\n\r\n//构造导出对象\r\nfunction Dynamic(rootNode :Elementy){return new App(rootNode);}\r\n((obj :anyObject)=>{\r\n    for(let i in obj) (Dynamic as anyObject)[i] = obj[i];\r\n})({\r\n    //引入模块\r\n    template, spa, manifest,\r\n    //工具方法\r\n    e(s: string, scope?: Element | Document) :Node | Node[]{return utils.element.e(s, scope);},\r\n    render(args :{\r\n        HTML :string | Element | HTMLCollection | Element[] | Node | NodeList | Node[],\r\n        element :Element, insertAfter? :boolean, append? :boolean\r\n    }) :Node[]{return utils.element.render(args.HTML, args.element, args.insertAfter, args.append);},\r\n    toHTML(HTML :string) :Node[]{return utils.element.toHTML(HTML)},\r\n    hatch(element :Element, remove? :boolean) :Node[]{return utils.element.hatch(element, remove);},\r\n    compose(){}, //todo:\r\n    //hack\r\n    __disableDevTools__,\r\n    __enableDevTools__\r\n});\r\n\r\n//导出\r\nutils.generic.constantize(Dynamic);\r\nexport default Dynamic;","/* dynamic\r\n * ©2022 LJM12914. https://github.com/wheelsmake/dynamic\r\n * Licensed under MIT License. https://github.com/wheelsmake/dynamic/blob/main/LICENSE\r\n*/\r\nimport Dynamic from \"./dynamic.export\";\r\n//fixed:当作模块使用的时候不需要弄到全局作用域，所以将这个东西抽出来了\r\nObject.defineProperty(window, \"Dynamic\", {\r\n    configurable: false,\r\n    writable: false,\r\n    enumerable: true,\r\n    value: Dynamic\r\n});"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","precisePop","ele","array","indexOf","splice","E","argument","type","reason","undefined","Error","console","error","noRepeat","input","Array","from","Set","e","s","scope","Element","document","a","querySelectorAll","length","match","toHTML","HTML","createElement","innerHTML","el","nodes","i","childNodes","cloneNode","getInnerNodesClone","render","element","insertAfter","append","parentElement","message","html","Node","HTMLCollection","NodeList","item","Rhtml","reverse","parent","prepend","nextSibling","insertBefore","FtoString","Function","toString","addExport","proxy","dataInstance","func","target","sE","shouldExports","checkArrowFunction","isDuplicated","warn","exportInstance","push","eliminateSymbol","property","advancedStringify","result","properties","keys","toStringed","compatibleToString","input_","object","objects","WeakMap","checkCycle","path","Boolean","Date","Number","RegExp","String","prev_path","$ref","set","newObj","JSON","stringify","addResult","input2","HTMLDSLs","l","r","twoWayBindingRegExp","oneWayBindingRegExp","nStwoWayBindingRegExp","nSoneWayBindingRegExp","App","constructor","rootNode","MutationObserver","records","record","this","has","Proxy","sharpData","deleted","cache","newValue","oldValue","processComputedProperty","exportInstances","shouldUpdates","dfsUpdate","dfsOldValue","shouldUpdate","shouldExport","shouldUpdateThis","string","inQuote","double","single","reversed","subCursor","substring","deleteProperty","exists","sharpMethods","bind","observe","attributes","attributeOldValue","characterData","characterDataOldValue","childList","subtree","data","_","dataProperty","removeExport","name","getExports","methods","$","hydrate","node","contains","register","getSearch","location","search","split","forEach","sp","getHash","hash","add","configurable","attrs","children","tasks","nameOne","nameTwo","valueOne","valueTwo","nameInserted","valueInserted","name_property","value_property","processed_avoidance_name","processed_avoidance_defaultTrap_name","symbol","funcObj","thisNode","valueOfAttr","getAttribute","removeAttribute","toLowerCase","setAttribute","HTMLInputElement","addEventListener","checked","attributeName","taskInstance","Text","textContent","text","twoWayInserts","matchAll","inserts","matchTwoWayBinding","matchOneWayBinding","HTMLElement","parentNode","appendChild","createTextNode","nextNode","NRproperties","template","replaceAll","cI","clearInterval","dtInterval","Dynamic","spa","manifest","args","hatch","remove","par","compose","__disableDevTools__","setInterval","id","window","__enableDevTools__","constantize","freeze","writable"],"sourceRoot":""}